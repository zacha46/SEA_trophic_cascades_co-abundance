---
title: "Step 1_Prepare data for bundling"
author: "Zachary Amir"
date: "2023-11-06"
output: html_document
---

## Introduction

This code will generate count histories and associated covariates and bundle the data to implement Zachary Amir's co-abundance models on the High Performance Computers (HPC).

Although it will not run effectively here, the code that runs on the HPC is included here (or maybe move to different script?)

This code works off the spatially re-sampled captures and covariates that are generated in the 4-step cam trap data standardization pipeline. See "Dropbox/CT capture histories database/R scripts CT data cleaning" for more info.

```{r setup, include=FALSE}

## start fresh
rm(list = ls())

## load libraries
library(tidyverse)
library(here)
library(plyr)
library(traitdata)

```

```{r import and inspect data, include=FALSE}

#### Resampled captures and metadata are saved per survey in a folder in the cap hist DB

### captures first 

## import and combine here
files = list.files("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step5_HPC_import_resampled_captures/")
files = files[!grepl("OLD", files)] # remove old data folder

## thin to the relevant scale were interested in -- 3km 
files = files[grepl("3km", files)]


## store caps here-
caps = list()

for(i in 1:length(files)){
  
  # select a file 
  f = files[i]
  
  # make the path 
  f_path = paste("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step5_HPC_import_resampled_captures/", f, sep = "")
  
  # read it
  d = read.csv(f_path)
  
  ## extract ID tag from file name
  id = strsplit(f, "_spatially_resampled_captures")[[1]][1]
  
  # remove the number
  id = gsub("^\\d+_", "", id)
  
  ## save it! 
  caps[[i]] = d
  names(caps)[i] = id
  
  ## let us know if there are any duplicate files in our repo
  if(any(duplicated(names(caps)))){
    print(paste("There are repeated files from the same survey with the tag:", id,
                "Make sure to remove it before importing!"))
  }# end conditional
  
} # end per file 
rm(f,f_path, d, id, i, files)

## combine list into a df
caps = do.call(rbind, caps)
rownames(caps) = NULL


### metadata next

## import and combine here
files = list.files("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step5_HPC_import_resampled_metadata/")
files = files[!grepl("OLD", files)] # remove old data folder

## thin to the relevant scale were interested in -- 3km 
files = files[grepl("3km", files)]


## store caps here-
meta = list()

for(i in 1:length(files)){
  
  # select a file 
  f = files[i]
  
  # make the path 
  f_path = paste("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step5_HPC_import_resampled_metadata/", f, sep = "")
  
  # read it
  d = read.csv(f_path)
  
  ## extract ID tag from file name
  id = strsplit(f, "_spatially_resampled_metadata")[[1]][1]
  
  # remove the number
  id = gsub("^\\d+_", "", id)
  
  ## save it! 
  meta[[i]] = d
  names(meta)[i] = id
  
  ## let us know if there are any duplicate files in our repo
  if(any(duplicated(names(meta)))){
    print(paste("There are repeated files from the same survey with the tag:", id,
                "Make sure to remove it before importing!"))
  }# end conditional
  
} # end per file 
rm(f,f_path, d, id, i, files)

## combine list into a df
meta = do.call(rbind, meta)
rownames(meta) = NULL


## ensure all cell_ids match!
setdiff(meta$cell_id_3km, caps$cell_id_3km)
setdiff(caps$cell_id_3km, meta$cell_id_3km) # good to go! 

## format classes
caps$Date = as.Date(caps$Date, format = "%Y-%m-%d")
meta$Sampling_begin = as.Date(meta$Sampling_begin, format = "%Y-%m-%d")
meta$Sampling_end = as.Date(meta$Sampling_end, format = "%Y-%m-%d")




#### Remove data that does not meet inclusion criteria

## Remove Brodie's data W of wallace line --> doesnt have relevant species
meta = meta[! grepl("E_Indonesia", meta$Landscape),]

# and thin caps to match
caps = caps[caps$survey_id %in% meta$survey_id,]


#### To be conservative, lets thin the data surveys with enough data

## summarize info about surveys
surv_summary = ddply(caps, .(survey_id), summarize,
                     num_SU = length(unique(cell_id_3km)), # total number of sampling units
                     max_cam = max(num_cams_active_at_date), # maximum number of cams active in a single sampling unit
                     dur = difftime(max(Date), min(Date), units= "days")) # duration of the survey 
## calculate trap nights 
surv_summary$trap_nights = surv_summary$num_SU * surv_summary$dur

## inspect SUs
summary(surv_summary$num_SU) # good spread, median is 9. 
# how many surveys w/ < 3 SUs? ( ~ 75% of 1st quarter)
length(surv_summary$survey_id[surv_summary$num_SU < 3]) / length(surv_summary$survey_id) * 100
## lose 15% just based on SU.
# A landscape should be at least 9 km2 to provide spatial variation, so lets stick with 3 as the minimum SUs.

## inspect effort
summary(as.numeric(surv_summary$trap_nights)) # good spread, median is 765
# how many surveys w/ < 200 tn ( ~ 33% of 1st quarter)
length(surv_summary$survey_id[surv_summary$trap_nights < 100]) / length(surv_summary$survey_id) * 100
## lose 12% just based on effort, probably overlap w/ above. 
# A survey should at least have 100 trapnights of effort as minimum for inclusion. 

## Extract surveys that do not meet inclusion criteria. 
rm = surv_summary$survey_id[as.numeric(surv_summary$trap_nights) < 100] # less than 100 trap nights 
rm2 = surv_summary$survey_id[(surv_summary$num_SU) < 3] # less than 3 sampling units in a survey 
rm = unique(c(rm,rm2))

## make a statement about it! 
print(paste("The number of rows that will be excluded from analysis because it is a survey w/ less than 100 trap nights or less than 3 sampling units in a survey are:", 
            dim(caps[caps$survey_id %in% rm,])[1],
            "and this represents:", 
            round(dim(caps[caps$survey_id %in% rm,])[1]  / dim(caps)[1] * 100, 3),
            "% of the full data."))
# nice! minimal losses. only 3.4% and 8882 rows removed from caps. 

## remove the data from caps
caps = caps[!caps$survey_id %in% rm,]

## and metadata
meta = meta[meta$survey_id %in% caps$survey_id,]

## keep environment clean
rm(surv_summary, rm,rm2)


## need survey year in covariates 
meta$year = str_extract(meta$survey_id, stringr::regex("(\\d+)(?!.*\\d)"))
sort(table(meta$year)) #looks good! 


```

### Determine which species to analyze

Here I will determine which species have sufficient detections (n = 100), standardize similar species to the genera level (e.g. Tragulus), and remove non-relevant species (e.g. blanks)

```{r select and standardize species to include, include=FALSE}

##### Which species will be included and how to standardize species?

## replace space with underscore to facilitate clean code/data
caps$Species = gsub(" ", "_", caps$Species)

# which species have sufficent (n=100) detections?
sp_count = ddply(caps, .(Species), summarize,
                 num_cap = length(Species))
keep = sp_count[sp_count$num_cap >= 100,]

## what did we get?
keep[order(keep$num_cap),] ## Awesome!! 
length(keep$Species) # 105 species before any cleaning 


## Standardize muntjacs, tragulus, Hystrix (?), Neofelis, Capricornis, Tupaia, maybe Canis_lupus
## remove from analysis: Ghost Homo_sapiens, unID'd, remove, Aves, bird, unkown, bird_pheasent, etc


### Clean up and combine some speices names

# Hystrix
sort(table(caps$Species[grepl("Hystrix", caps$Species)])) ## dont change crassispinis or brachyura b/c we have enough! 
# caps$Species[caps$Species %in% c("Hystrix_brachyura", "Hystrix")] = "Hystrix_genus"

# Muntjac
sort(table(caps$Species[grepl("Munt", caps$Species)])) # ecologically very similar species, but what about spatial distribution?
## where do all these muntjacs come from?
Ma = caps$cell_id_3km[caps$Species == "Muntiacus_atherodes"]
unique(meta$Landscape[meta$cell_id_3km %in% Ma]) # Sarawak and Sabah.
Mr = caps$cell_id_3km[caps$Species == "Muntiacus_reevesi"]
unique(meta$Landscape[meta$cell_id_3km %in% Mr]) # Sarawak, Sabah, Sumatra, and S. Thailand...
Mv = caps$cell_id_3km[caps$Species == "Muntiacus_vaginalis"]
unique(meta$Landscape[meta$cell_id_3km %in% Mv]) # Thailand, Vietnam, China
Mm = caps$cell_id_3km[caps$Species == "Muntiacus_muntjak"]
sort(unique(meta$Landscape[meta$cell_id_3km %in% Mm])) # Laos, P_Malaysia, Sarawak, Sabah, Sumatra, Thailand (many)
M = caps$cell_id_3km[caps$Species == "Muntiacus"]
sort(unique(meta$Landscape[meta$cell_id_3km %in% M])) # Laos, Sarawak, Thailand (many), Vietnam.
## These are all quite spatially distinct, so there is good motivation to combine these species into one
# Make sure to save independent detections of all for supplementary materials later! 
rm(Ma, Mr, Mv, Mm, M)

## combine
caps$Species[grepl("Munt", caps$Species)] = "Muntiacus_genus"

# clouded leopards
sort(table(caps$Species[grepl("Neof", caps$Species)])) #just geographical differences, but way more bornean than mainland! 
caps$Species[grepl("Neof", caps$Species)] = "Neofelis_genus"

# mousedeer
sort(table(caps$Species[grepl("Trag", caps$Species)])) #Amazed that these are even differentiated 
caps$Species[grepl("Trag", caps$Species)] = "Tragulus_genus"

# serow
sort(table(caps$Species[grepl("Capric", caps$Species)])) #I think these were recently combined by taxonomists anyway 
caps$Species[grepl("Capric", caps$Species)] = "Capricornis_genus"

# treeshrew
sort(table(caps$Species[grepl("Tupai", caps$Species)])) #Amazed that these are even differentiated 
caps$Species[grepl("Tupai", caps$Species)] = "Tupaia_genus"

#dogs
sort(table(caps$Species[grepl("Canis_lup", caps$Species)])) #Just call these dogs, we dont have pics to know if domestic or not 
caps$Species[grepl("Canis_lup", caps$Species)] = "Canis_lupus_familiaris"

# mongoose
sort(table(caps$Species[grepl("Herpe", caps$Species)])) # Just stick with H_urva and H_brachyrus 
caps$Species[caps$Species %in% c("Herpestes", "Herpestes_semitorquatus",
                                 "Herpestidae")] = "Herpestes_genus" # this will get excluded later anyway b/c we have more specific species, which is better. 

# Murids
unique(caps$Species[grepl("Muri", caps$Species)]) #only the family muridae
caps$Species[grepl("Muri", caps$Species)] = "Muridae_spp" #spp denotes family here. 

#squirells 
unique(caps$Species[grepl("Sciur", caps$Species)]) #only the family sciuridae
caps$Species[grepl("Sciur", caps$Species)] = "Sciuridae_spp"


#Combine northern and southern pig tail macaques into one species Macaca_leonina Macaca_nemestrina 
sort(table(caps$Species[grepl("Macaca_", caps$Species)]))
caps$Species[caps$Species %in% c("Macaca_leonina", "Macaca_nemestrina" )] = "Macaca_nemestrina"

#chickens
unique(caps$Species[grepl("Gallu", caps$Species)]) #analyze at genus level. 
caps$Species[startsWith(caps$Species, "Gallus")] = "Gallus_genus"

## attach genus to the other Genera names that need it to stay consistent
caps$Species[caps$Species %in% c("Amaurornis", "Macaca", "Hystrix",
                                 "Maxomys","Melogale", "Varanus")] = paste(caps$Species[caps$Species %in% c("Amaurornis", "Macaca",
                                                                                                            "Hystrix","Maxomys","Melogale", "Varanus")], "genus", sep = "_")


### Make a new species count w/ updated species names
sp_count = ddply(caps, .(Species), summarize,
                 num_cap = length(Species))
keep = sp_count[sp_count$num_cap >= 100,]

## what did we get?
sort(keep$Species) #reduced to 90 species

# remove some of the not useful fluff
keep = keep[!keep$Species %in% c("Aves", "Ghost", "Mammalia",
                                 "Unknown","Vehicle"),] 

#remove all  people 
keep = keep[!grepl("Homo", keep$Species ),] 

# remove species not ID to the species or genus level 
keep = keep[!endsWith(keep$Species, "_spp"),]
# and the others. 
keep = keep[! keep$Species %in% c("Scincidae","Small_mammal", "Herpestidae",
                                  "Phasianidae", "Rodentia","Scandentia"),]

length(keep$Species) # 73 species after removing fluff. 
rm(sp_count)

### Looks good, but will remove more species once body weights are accounted for. 
sort(keep$Species)

## save it as a vector, not dataframe
keep = keep$Species

```

### Determine species traits

Here I am generating all species data from the library(speciestraits) databases, cleaning where necessary, and generating trait data for combined genera based off representative species. Each species should have 1) a trophic level (i.e., carnivore, omnivore, herbivore), and body mass (in grams). I will also add information about the dietary preferences for the 4 main large carnivores for each species, where the column will be a "Yes" or "No" if the literature supports it being a preferred prey species. I will try to include missing information from outside sources, but if none is available, species without trait data will be discarded.

```{r generate species trait data, include=FALSE}

## access panthera dataset
pan = pantheria
# replace space with underscore for species names to match our style
pan$scientificNameStd = gsub(" ", "_", pan$scientificNameStd)

## access mammal_diet dataset
mam = mammal_diet2
mam = as.data.frame(mam) # remove silly tibble
# replace space with underscore for species names to match our style
mam$scientificNameStd = gsub(" ", "_", mam$scientificNameStd)
## remove NA species names
mam = mam[!is.na(mam$scientificNameStd),]


## import Sam Lee's cleaned avonet dataframe
bird = read.csv(here::here("data/species_traits/bird_guild_information_20221102.csv"))

# replace space with underscore for bird species names
bird$Species = gsub(" ", "_", bird$Species)

## check which species we have matches for 
intersect(bird$Species, keep) # 12 matches and all birds, great! 
# thin bird to relevant species
bird = bird[bird$Species %in% c(keep, "Gallus_gallus"),]
bird$Species[bird$Species == "Gallus_gallus"] = "Gallus_genus" #std to match

## copy "Amaurornis_phoenicurus" and provide for genus Amaurornis catch-all
am = bird[bird$Species == "Amaurornis_phoenicurus",]
am$Species = "Amaurornis_genus" 
bird = rbind(bird,am)
rm(am)

## access a dataset for varanus salvator 
rep = lizard_traits
# thin to our singular herp species
rep = rep[rep$scientificNameStd == "Varanus salvator",] # good! 
rep = rep[!is.na(rep$scientificNameStd),] # idk why, but it comes with lots of NA
# make sure species name is consistent!
rep$scientificNameStd = gsub(" ", "_", rep$scientificNameStd)
# thin to relevant info
rep = select(rep, scientificNameStd, diet) # missing body wieght

## adding custom body weight as determined by Shine et al 1996, "Commercial harvesting of giant lizards: The biology of water monitors Varanus salvator in southern Sumatra"
rep$Body_mass = 3.24
names(rep)[2] = "TrophicLevel"

## add a second row of rep for Varanus catch-all genus
rep = rbind(rep,rep)
rep$scientificNameStd[2] = "Varanus_genus"

## rbind w/ our birds
names(bird)[1:2] = c("scientificNameStd","TrophicLevel")
rep_bird = rbind(rep, bird)

# convert kg masses to grams to match mammal format 
rep_bird$Body_mass = rep_bird$Body_mass * 1000
names(rep_bird)[3] = "AdultBodyMass_g"

## thin mam and pan to relevant info while incorporating known typo
mam = select(mam[mam$scientificNameStd %in% c(keep, "Taperus_indicus", 
                                              "Canis_lupus"),], scientificNameStd, TrophicLevel) # diet from here
pan = select(pan[pan$scientificNameStd %in% c(keep, "Taperus_indicus", 
                                              "Canis_lupus"),], scientificNameStd, AdultBodyMass_g) # mass from here

# and merge together
mam_pan = distinct(merge(mam, pan, by = "scientificNameStd"))

# There are two duplicated rows, remove them! 
a = mam_pan[mam_pan$scientificNameStd == "Callosciurus_notatus" & !is.na(mam_pan$AdultBodyMass_g),] # remove dup w/out mass
b = mam_pan[mam_pan$scientificNameStd == "Atherurus_macrourus" & 
              mam_pan$TrophicLevel == "Herbivore",] # remove dup w/ omnivore tag for porcupine
c = rbind(a,b)
## remove bad species
mam_pan = mam_pan[!mam_pan$scientificNameStd %in% c("Atherurus_macrourus", "Callosciurus_notatus"),]
## and rbind good records of those species
mam_pan = rbind(mam_pan, c)
rm(a,b,c)


# Now combine them all!
traits = rbind(mam_pan, rep_bird)

## check which species are missing 
setdiff(keep, traits$scientificNameStd) # 12, though mostly genera or a few typos 

## fix obvious typos first
traits$scientificNameStd[traits$scientificNameStd == "Taperus_indicus"] = "Tapirus_indicus"
traits$scientificNameStd[traits$scientificNameStd == "Canis_lupus"] = "Canis_lupus_familiaris"

## add 10 missing species to traits object
traits[64:(64+9), "scientificNameStd"] = setdiff(keep, traits$scientificNameStd)

### re-load mam and pam to include other species
# pan
pan = pantheria
pan$scientificNameStd = gsub(" ", "_", pan$scientificNameStd)
pan = select(pan, scientificNameStd, AdultBodyMass_g)
# mam
mam = mammal_diet2
mam = as.data.frame(mam) # remove silly tibble
mam$scientificNameStd = gsub(" ", "_", mam$scientificNameStd)
mam = mam[!is.na(mam$scientificNameStd),]
mam = select(mam, scientificNameStd, TrophicLevel)


## add info per species/guild
#serow
traits[traits$scientificNameStd == "Capricornis_genus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Capricornis_sumatraensis"]
traits[traits$scientificNameStd == "Capricornis_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Capricornis_sumatraensis"]

# mongooses 
traits[traits$scientificNameStd == "Herpestes_genus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Herpestes_urva"]
traits[traits$scientificNameStd == "Herpestes_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Herpestes_urva"]

#muntjacs
traits[traits$scientificNameStd == "Muntiacus_genus", "TrophicLevel"] = unique(mam$TrophicLevel[mam$scientificNameStd == "Muntiacus_muntjak"])
traits[traits$scientificNameStd == "Muntiacus_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Muntiacus_muntjak"]

#clouded leopards
traits[traits$scientificNameStd == "Neofelis_genus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Neofelis_nebulosa"]
traits[traits$scientificNameStd == "Neofelis_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Neofelis_nebulosa"]

#mousedeer
traits[traits$scientificNameStd == "Tragulus_genus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Tragulus_napu"]
traits[traits$scientificNameStd == "Tragulus_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Tragulus_napu"]

#gaur
traits[traits$scientificNameStd == "Bos_gaurus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Bos_javanicus"]
traits[traits$scientificNameStd == "Bos_gaurus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Bos_javanicus"]

#porcupines
traits[traits$scientificNameStd == "Hystrix_genus", "TrophicLevel"] = unique(mam$TrophicLevel[mam$scientificNameStd == "Hystrix_brachyura"])
traits[traits$scientificNameStd == "Hystrix_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Hystrix_brachyura"]

#maxomys
traits[traits$scientificNameStd == "Maxomys_genus", "TrophicLevel"] = mam$TrophicLevel[mam$scientificNameStd == "Maxomys_rajah"] # widespread in Sundaland
traits[traits$scientificNameStd == "Maxomys_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Maxomys_rajah"]

#Tupaia_genus
traits[traits$scientificNameStd == "Tupaia_genus", "TrophicLevel"] = unique(mam$TrophicLevel[mam$scientificNameStd == "Tupaia_glis"])
traits[traits$scientificNameStd == "Tupaia_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Tupaia_glis"]

#Macaca
traits[traits$scientificNameStd == "Macaca_genus", "TrophicLevel"] = unique(mam$TrophicLevel[mam$scientificNameStd == "Macaca_nemestrina"]) # maybe silly b/c already present?
traits[traits$scientificNameStd == "Macaca_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Macaca_nemestrina"]

#Melogale
traits[traits$scientificNameStd == "Melogale_genus", "TrophicLevel"] = unique(mam$TrophicLevel[mam$scientificNameStd == "Melogale_moschata"]) 
traits[traits$scientificNameStd == "Melogale_genus", "AdultBodyMass_g"] = pan$AdultBodyMass_g[pan$scientificNameStd == "Melogale_moschata"]

### two civets are missing weights!! 
# Hose civet
traits$AdultBodyMass_g[traits$scientificNameStd == "Diplogale_hosei"] = 2500 #https://www.ecologyasia.com/verts/mammals/hose's-civet.htm
# large spotted civet
traits$AdultBodyMass_g[traits$scientificNameStd == "Viverra_megaspila"] = 6600 #https://en.wikipedia.org/wiki/Large-spotted_civet

### Inspect
anyNA(traits) # must be F
# traits[is.na(traits$AdultBodyMass_g),]


## double check
setdiff(keep, traits$scientificNameStd) # full match! 
setdiff(traits$scientificNameStd, keep) # full match! 
## should be good to go! 

rm(mam,pan, bird,rep, rep_bird, mam_pan)


## each macaque species has a different guild (omni, herb, and carn), 
## standardize to omnivore
traits$TrophicLevel[grepl("Macaca", traits$scientificNameStd)] = "Omnivore"
## make all bears omnivores, not herbivore as currently recognized
traits$TrophicLevel[traits$scientificNameStd %in% c("Helarctos_malayanus", "Ursus_thibetanus")] = "Omnivore"
## make all Lophura herbivores
traits$TrophicLevel[grepl("Lophura", traits$scientificNameStd)] = "Herbivore"
## caught a typo from the rep data base to be corrected here
traits$TrophicLevel[traits$TrophicLevel == "Carnivorous"] = "Carnivore"
## Orangutans should be herbivores, not omnivores
traits$TrophicLevel[traits$scientificNameStd == "Pongo_pygmaeus"] = "Herbivore"

# make body mass numeric 
traits$AdultBodyMass_g = as.numeric(traits$AdultBodyMass_g)

## We do NOT want to analyze anything < 1kg in body mass, so remove them here
# which do we lose?
sort(traits$scientificNameStd[traits$AdultBodyMass_g < 1000]) 
## double checked old results for those >500g, and doesnt seem like we will miss much here... REMOVE
traits = traits[traits$AdultBodyMass_g > 1000,]
## also remove anything over 1000 kg, which is too large to be preyed upon 
sort(traits$scientificNameStd[traits$AdultBodyMass_g > 1000000])  # just elephants
traits = traits[traits$AdultBodyMass_g < 1000000,]

## We are also NOT interested in examining domestic animals, so remove them here
traits = traits[! traits$scientificNameStd %in% c("Canis_lupus_familiaris", "Bos_taurus"), ]

## There is also no point analyzing species that are ID'd at the genus level AND species level --> extra noise
traits = traits[! traits$scientificNameStd %in% c("Herpestes_genus", "Hystrix_genus", "Macaca_genus", "Varanus_genus" ), ]

## also do not include species that are primarily arboreal --> orangutans, langur, tufted squirrell any anyone else?
traits = traits[! traits$scientificNameStd %in% c("Pongo_pygmaeus", "Presbytis_rubicunda", "Rheithrosciurus_macrotis"), ]

# thin keep to match 
keep = keep[keep %in% traits$scientificNameStd]



## add small and large to trophic levels 
traits$TrophicGuild = traits$TrophicLevel

# inspect omnivores first --> 50 kg cut off for omnivores
traits$scientificNameStd[traits$TrophicLevel == "Omnivore"] 
traits$TrophicGuild[traits$TrophicLevel == "Omnivore" & 
                      traits$AdultBodyMass_g < 50000] = "Small_Omnivore"
traits$TrophicGuild[traits$TrophicLevel == "Omnivore" & 
                      traits$AdultBodyMass_g > 50000] = "Large_Omnivore"
# inspect
sort(table(traits$TrophicGuild[traits$TrophicLevel == "Omnivore"]))


## herbivores --> 100 kg cut off
traits$scientificNameStd[traits$TrophicLevel == "Herbivore"] # good mix
traits$TrophicGuild[traits$TrophicLevel == "Herbivore" & 
                      traits$AdultBodyMass_g < 100000] = "Small_Herbivore"
traits$TrophicGuild[traits$TrophicLevel == "Herbivore" & 
                      traits$AdultBodyMass_g > 100000] = "Large_Herbivore"
# inspect
sort(table(traits$TrophicGuild[traits$TrophicLevel == "Herbivore"]))

## Carnivores --> 15kg cut off (but just less than 15 to accomodate clouded leopards)
traits$scientificNameStd[traits$TrophicLevel == "Carnivore"] # 
traits$TrophicGuild[traits$TrophicLevel == "Carnivore" & 
                      traits$AdultBodyMass_g < 14940] = "Small_Carnivore"
traits$TrophicGuild[traits$TrophicLevel == "Carnivore" & 
                      traits$AdultBodyMass_g > 14940] = "Large_Carnivore"
# inspect
sort(table(traits$TrophicGuild[traits$TrophicLevel == "Carnivore"]))


table(traits$TrophicGuild) # looks good! 
## many more small than large, but this is to be expected. 

#
##
###
#### Add dietary preferences of the large carnivores

### The goal here is to determine if large carnivores have different effects 
## when looking at 'preferred' prey species vs non-preferred species. 
# Ideally, just add a yes-no column to the guilds dataframe for each large carnivore. 

# Diet changes so much based on habitat, interactions, and time of year... 
# All species seem to prefer to some degree Sus scrofa based on readings. 

#### Tigers
# https://zslpublications.onlinelibrary.wiley.com/doi/full/10.1111/j.1469-7998.2011.00871.x
# suggests preferred weight range of 60-250 kg, and wil eat the largest available prey.... So anything >= 60 kg to accomodate tapir, gaur, and cattle
### Change minimum wieght to 17 kg to include muntjac and cite eco-evo paper about it. 
## and can cite Allan Rabinowitz about it: https://thesiamsociety.org/wp-content/uploads/2020/04/NHBSS_037_2k_Rabinowitz_TheDensityAndB.pdf
traits$tiger_pref = "No"
traits$tiger_pref[traits$AdultBodyMass_g > 17000] = "Yes"
traits$tiger_pref[traits$scientificNameStd == "Panthera_tigris"] = "NA" # no cannibals allowed. 
# who is preferred?
sort(traits$scientificNameStd[traits$tiger_pref == "Yes"]) # 10 species, ok
# black bear made it in, and this MS says they are preyed upon by tigers in Laos: https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.9067
# Might as well leave sun bear in here too. 
#who is missing?
sort(traits$scientificNameStd[traits$tiger_pref == "No"]) # seems ok, 33 species

#### Leopards 
#  https://doi.org/10.1111/j.1469-7998.2006.00139.x
# suggest preferred weight range of 10-40 kg. 
# https://www.sciencedirect.com/science/article/pii/S0006320712005149 
# langurs/primates, pigs when tigers are absent. 
# https://royalsocietypublishing.org/doi/10.1098/rsos.171187
# suggest large prey (Banteng/Gaur) is possible in the absence of tigers, but not common and restricted to males. 
# https://thesiamsociety.org/wp-content/uploads/2020/04/NHBSS_037_2k_Rabinowitz_TheDensityAndB.pdf
# Muntjac (for tigers too), then primates, then pig == sambar == porcupines == hog badger 
# https://thesiamsociety.org/wp-content/uploads/2020/04/NHBSS_047_1l_Grassman_EcologyAndBehavi.pdf
# Suggests hog badger is important too. 

traits$leopard_pref = "No"
traits$leopard_pref[traits$AdultBodyMass_g > 10000 & traits$AdultBodyMass_g <= 40000] = "Yes"
traits$tiger_pref[traits$scientificNameStd == "Panthera_pardus"] = "NA" # no cannibals allowed. 
# who is preferred?
traits$scientificNameStd[traits$leopard_pref == "Yes"] # 4 species, mostly carnivores
## exclude clouded leopards and dholes, leave dogs tho (evidence from india)
traits$leopard_pref[traits$scientificNameStd %in% c("Cuon_alpinus","Neofelis_genus")] = "No"
## also add primates and pigs based off readings
traits$leopard_pref[grepl("Macac", traits$scientificNameStd)] = "Yes" # only include macaques. 
## include pigs and hog badger 
traits$leopard_pref[traits$scientificNameStd %in% c("Sus_scrofa","Arctonyx_collaris")] = "Yes"
# who is preferred now?
sort(traits$scientificNameStd[traits$leopard_pref == "Yes"]) # 7 species, better! 
#who is missing?
sort(traits$scientificNameStd[traits$leopard_pref == "No"]) # seems ok, 38 species --> nothing obvious to include here. 


#### Dholes
# https://zslpublications.onlinelibrary.wiley.com/doi/10.1111/jzo.12171
## Hayward style pref wieght range of 130â€“190 kg, and highlights sambar as important. 
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9388674/
## scat analysis that emphasizes large deer (sambar + chital), pigs and muntjac were moderetly avoided but still consumed.
# https://doi.org/10.1016/j.mambio.2013.08.007
## lit review of scats and abundance: 40 and 60 kg weight range, sambar preferred most. 
### Matthew suggests a drop down to 10 kg, but wait for citation from him --> would only add binturongs anyway... 
traits$dhole_pref = "No"
traits$dhole_pref[traits$AdultBodyMass_g > 40000 & traits$AdultBodyMass_g < 190000 &
                    traits$TrophicGuild != "Large_Carnivore"] = "Yes"
# who is preferred?
traits$scientificNameStd[traits$dhole_pref == "Yes"] # Some species here dont make sense: bears --> remove! 
# remove bears, no evidence for this! 
traits$dhole_pref[traits$scientificNameStd %in% c("Helarctos_malayanus", "Ursus_thibetanus")] = "No"
## Adding muntjac because they are consumed according to lit (eaten by everything)
traits$dhole_pref[traits$scientificNameStd %in% c("Muntiacus_genus")] = "Yes"
# who is preferred?
traits$scientificNameStd[traits$dhole_pref == "Yes"] # 5 species now... just ok. 
#who is missing?
sort(traits$scientificNameStd[traits$dhole_pref == "No"]) # seems ok, 38 species --> nothing obvious to include here. 


#### Clouded leopards
# https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.9067 
# Serow! Ungulates in particular. No evidence for primates in this citation,
# but evidence from elsewhere for primates, and generally evidence for a varied and wide diet. 
# https://www.sciencedirect.com/science/article/pii/S235198941930976X#bib14
# Evidence for small carnivores as prey --> vivverids (but not other cats) fit! 
# http://cloudedleopardpartners.org/wp-content/uploads/2021/03/2015-First-description-of-population-density-_-habitat-use-of-the-mainland-clouded-leopard-within-a-logged-primary-forest-in-South-East-Asia-PopulationEco.pdf
# Evidence for prey < 10 kg, tho old outdated methods. 
# Justification 
traits$CL_pref = "No"
traits$CL_pref[traits$AdultBodyMass_g > 7000 & traits$AdultBodyMass_g < 190000 &
                 traits$TrophicGuild != "Large_Carnivore"] = "Yes"
# who is preferred?
traits$scientificNameStd[traits$CL_pref == "Yes"] # Remove some of the larger carnivores (e.g. bears, cats), but leaving binturong b/c evidence exists! https://www.researchgate.net/publication/271701967_First_record_of_a_clouded_leo-pard_predating_on_a_binturong
traits$CL_pref[traits$scientificNameStd %in% c("Catopuma_temminckii", "Helarctos_malayanus", "Ursus_thibetanus")] = "No"

# who is preferred?
traits$scientificNameStd[traits$CL_pref == "Yes"] # 12 species now... more than tigers! b/c of small carnivores
#who is missing?
sort(traits$scientificNameStd[traits$CL_pref == "No"]) # seems ok, 32 species --> nothing obvious to include here. 



```

### Prepare data to be bundled

Now that relevant species have been determined and species traits are sorted out, I can begin formatting the data to run in the co-abundance models. This will involve making a count history matrix for each species and generating key covariates to be included as well. Will be using the captures and metadata files imported from the first code chunk to do this.

First, I will generate a sampling occasion index in the captures. Instead of creating a detection history matrix based on the date a photo was taken, I make all cameras start on the same 'day' (based around start/end dates) to increase model speed and efficiency.

```{r Generate a sampling occasion index in the captues, echo=F, include=FALSE}

## Instead of creating a detection history matrix based on the date a photo was taken
## make all cameras start on the same 'day' to increase model speed and efficiency. 

### Create a data frame with each sampling unit as a row, with start and stop dates
s = distinct(dplyr::select(meta, cell_id_3km, Sampling_begin, Sampling_end))  

## split the dataframe by cell_id_3km, and add the full sequence of dates between start/stop dates. 
s2 = ddply(s, .(cell_id_3km), summarize,
           Date = as.character(seq.Date(from = min(Sampling_begin), to = (max(Sampling_end)), by = 1)))


#That worked, now bring back the start and stops. Make sure you dont loose records
dim(s2) #264568
t = merge(s2, s, by = "cell_id_3km")
dim(t) #264568, good! 


## Add sequence from 1-n for each sampling unit
res = t[0,]
res$seq = numeric()

for(i in unique(t$cell_id_3km)){
  
  d = t[t$cell_id_3km == i,]
  
  d$seq = as.numeric(seq(from= 1, 
                         to = unique(as.numeric(difftime(d$Sampling_end+1, # Add one to start seq on 1 instead of 0
                                                         d$Sampling_begin, units = "days"))), by = 1))
  
  res = rbind(res, d)
}
rm(d,i)

#inspect
str(res)
dim(res) #264568 , same as before! Good! 

## Make sure all cams got accounted for
setdiff(res$cell_id_3km, unique(caps$cell_id_3km))
setdiff(unique(caps$cell_id_3km), res$cell_id_3km) # no difference

## merge the sequence with the captures
t = merge(caps, res, by = c("cell_id_3km", "Date"))
dim(caps) #252228
dim(t) #252128, not exactly the same...

## How much did we lose?
print(paste("By adding the observation sequence to the captures, we lost ", 
             round((nrow(caps) - nrow(t))/nrow(caps) * 100, 2), "% of the data", sep = ""))
## this is an acceptable amount 

## Captures are all good with updated observation sequence! 
# head(t)
caps = t

## keep your global environment clutter free
rm(t, s, s2, res)

```

In the past, particularly the Eco & Evo co-abundance publication, I assigned "natural absences" as landscapes where the species was not found in either the Anthropocene or the Holocene by assigning NA values for landscapes based on 4 broad distributions: Borneo, Sumatra, and North/South Mainland (based on the Isthmus of Kra). However, I am not doing this anymore because we are interested in prey abundance with or without predators, regardless of historical distributions. Therefore, there is no longer any need to generate an "extirpation_DF" to assign landscapes as present, absent or NA because we are using data from ALL sites. However, from a purley computational stance, subsetting to sites where species are historically present/absent should expedite the analysis by removing many rows! 

Generating the data bundles on a regular computer will take hours, so instead I will send the information to the High Performance Computers (HPC) to run much faster. Before sending off the data, I will determine which species need to be analyzed as groups (because of very large group sizes, e.g. dholes and macaques).

```{r save data to send to HPC for bundling, echo=FALSE}

## first, determine which species will need to be analyzed as groups rather than individuals 
# because of very large group sizes skewing results
big = ddply(caps[caps$Species %in% keep,], .(Species), summarize,
            max_count = max(total_indiv_records),
            mean_count = mean(total_indiv_records),
            mode_count = median(total_indiv_records))

big$Species[big$mean_count >= 2] #this is probably it... 
# big$Species[big$max_count >= 10] #but this is concerning 

## go w/ mean >= 2 for now and inspect for later
group_sp = big$Species[big$mean_count >= 2]
# adding muntjacs and ALL macaque species because they were probelmatic in the past 
group_sp = c(group_sp, "Muntiacus_genus", "Macaca_fascicularis" )
rm(big)


### Found a downstream error! Sampling units w/ too many active cameras were causing models to crash! 
# create a new column in the metadata that counts the number of active cams per SU
meta$cams_included_count = str_count(meta$cameras_included, " - ") + 1
hist(meta$cams_included_count) # classic Poisson

## > 7 cams per SU was causing probelms earlier... 
# how many SUs do we lose by exclusing them?
nrow(meta[meta$cell_id_3km %in% meta$cell_id_3km[meta$cams_included_count > 7],]) / nrow(meta) * 100
# 4% of SUs, thats fine. 


### Also verify key covariates we are intersted in are not strongly correlated 
check = select(meta, Avg_FLLI_3km, Avg_human_footprint_3km, Avg_altitude_3km, Avg_hunting_accessibility_3km)
cov.corr = cor(check[,sapply(check, is.numeric)])
cov.corr= as.data.frame(cov.corr)
cov.corr[abs(cov.corr) < abs(.6)] = "good" # stick w/ .6 b/c FLII and HFP are 0.5 correlated. 
rm(check, cov.corr)

## grab today's date 
day<-str_sub(Sys.Date(),-2)
month<-str_sub(Sys.Date(),-5,-4)
year<-str_sub(Sys.Date(),-10,-7)
date = paste(year,month,day, sep = "")

# ### Save all relevant files
# saveRDS(keep, paste("/Users/zachary_amir/Dropbox/Zach PhD/Trophic release project/SEA_trophic_cascades_co-abundance/data/send_to_HPC/species_vector_", length(keep), "_species_", date, ".RDS", sep = ""))
# 
# saveRDS(group_sp, paste("/Users/zachary_amir/Dropbox/Zach PhD/Trophic release project/SEA_trophic_cascades_co-abundance/data/send_to_HPC/group_living_", length(group_sp), "_species_", date, ".RDS", sep = ""))
# 
# write.csv(caps, paste("/Users/zachary_amir/Dropbox/Zach PhD/Trophic release project/SEA_trophic_cascades_co-abundance/data/send_to_HPC/clean_captures_to_make_UMFs_", date,".csv", sep = ""), row.names = F)
# 
# write.csv(meta, paste("/Users/zachary_amir/Dropbox/Zach PhD/Trophic release project/SEA_trophic_cascades_co-abundance/data/send_to_HPC/clean_metadata_to_make_UMFs_", date,".csv", sep = ""), row.names = F)
# 
# ### Also save trait data so I dont have to remake it later
# write.csv(traits, paste("/Users/zachary_amir/Dropbox/Zach PhD/Trophic release project/SEA_trophic_cascades_co-abundance/data/species_traits/clean_", nrow(traits), "_species_trait_data_", date, ".csv", sep = ""), row.names = F)
rm(day, month, year, date)


```

### HPC matrix and covariate creation code

The following code is set up to run on the HPC and lives as its own separate R script. The code will not run in this markdown document, but I am keeping it here for good measure.

The separate R script is called: scripts/HPC_code/HPC_matrix_generator.R.

To make that code run on the HPC, I use the SLURM script called: scripts/SLURM_code/SLURM_generate_matricies_20230615.txt

To avoid any confusion, I will not include that code here (for now) because it will not run locally.

### Generate data bundles

Import matrix data that was formatted on the HPC via loop. Objects were saved as .RDS files because they were list(), and I will save all lists in a singular bigger list. A list of lists if you will.

```{r import HPC data via loop, echo=FALSE}

## Store imported data here
umfs = list()

## list all files that should be imported 
files = list.files(here::here("data/import_UMF_from_HPC"))
files = files[!grepl("OLD", files)] # remove any old data 

for(i in 1:length(files)){
  
  #import the file
  f = files[i]
  path = paste("data/import_UMF_from_HPC/", f, sep = "")
  u = readRDS(here::here(path))
  
  #save it in a list 
  umfs[[i]] = u
  names(umfs)[i] = paste0(str_split(f, "_")[[1]][2:3], collapse = "_")
  
}
rm(i,u,f,path, files)

sort(names(umfs)) # looks good

## check if all species are present by importing old species vector
setdiff(keep, names(umfs)) # present and accounted for! 

# ### inspect present data
# head(umfs$Panthera_pardus$siteCovs) #nice
# head(umfs$Sus_barbatus$ObsCovs) #nice
# head(umfs$Ursus_thibetanus$y) #nice
# ## should be good to go! 

```

Now that the data is loaded in our environment, we will create co-abundance data bundles that will be ready to run on the HPC. Bundles will be generated for species pairs, where one species is explicitly assigned as a dominant species (predictor/independent variable), while the other is the subordinate species (response/dependent variable). Bundles will be generated based on spatial associations (i.e. the critters need to be present in at least one landscape together), and retained based on our preferred interactions we wish to examine. In particular, this means large carnivores acting as dominant over all other guilds, and large+small herbivores+ominivores acting as dominant to large carnivores.

```{r Ultra-Loop to generate data bundles based on guild-pairs, echo=FALSE }

## bind landscapes to captures to facilitate finding where critters are detected
l = distinct(select(meta, survey_id, Landscape))
caps = merge(caps, l, by = "survey_id")
rm(l)

#create a list to store results
bdata_list = list()

for(i in 1:length(umfs)){ # repeat for each first speices
  
  ## select a single species and thier data 
  # 1st species is the dominant! 
  sp_dom = names(umfs)[i]
  sp_dom_dat = umfs[[i]]
  
  ## grab the trophic guild of the dom species
  dom_tg = traits$TrophicGuild[traits$scientificNameStd == sp_dom]
  
  ## subset all other species
  all_else = names(umfs)
  all_else = all_else[all_else != sp_dom] # remove first species
  
  ### Thin all_else based upon the dominant species traits to avoid making too many models
  
  # if the dominant species is large+small herbivores+ominivores,
  if(dom_tg %in%  c("Small_Omnivore", "Large_Omnivore",
                    "Small_Herbivore","Large_Herbivore")){
    
    ## Then sub_species should only be large carnivores
    all_else = all_else[all_else %in%
                          traits$scientificNameStd[traits$TrophicGuild == "Large_Carnivore"]]

  } # end sub large carnivore conditional 
  
  # if the dominant species is a small carnivore,
  if(dom_tg == "Small_Carnivore"){
    
    ## skip it! 
    next
  }
  
  temp = list() # store results per sp1 here 
  for(l in 1:length(all_else)){ # repeat for each second species
    
    ## select a second species and their data
    # 2nd species is the subordinate! 
    sp_sub = all_else[l]
    sp_sub_dat = umfs[[sp_sub]]
    
    ##### Add a conditional to verify there are a combined total of 100 detections
    ##### shared across the landscapes where BOTH species were detected. 
    
    ## Grab landscapes present for each species
    dom_land = unique(caps$Landscape[caps$Species == sp_dom])
    sub_land = unique(caps$Landscape[caps$Species == sp_sub])
    ## and only save the ones where they intersect 
    lands = intersect(dom_land, sub_land)
    rm(dom_land, sub_land)
    
    ## gather number of detections at shared landscapes for both species
    dom_det = nrow(caps[caps$Species == sp_dom &
                          caps$Landscape %in% lands,])
    sub_det = nrow(caps[caps$Species == sp_sub &
                          caps$Landscape %in% lands,])
    
    ## if there are less than 100 detections of both species from shared landscapes, 
    if(dom_det + sub_det < 100){
      # let us know
      print(paste("The species combo of", sp_sub, "~", sp_dom, 
                  "have less than 100 detections in shared landscapes! This pair was skipped."))
      # and skip the probelmatic pair
      next
      
    } # end 100 detection conditional 
    rm(dom_det, sub_det, lands)
    ## this conditional will also catch species pairs that dont spatially overlap, 
    ## where a conditonal does that below and isnt needed anymore, but leaving for saftey. 
    
    #
    ##
    ###
    #### Remove landscapes where neither species was detected and convert to matrix
    ###
    ##
    #
    
    ## First, determine which landscapes species are extirpated in
    exp = distinct(select(caps[caps$Species %in% c(sp_sub, sp_dom),], Landscape, Species))
    exp$presence = "yes"
    
    ## need to add landscapes where Species was NOT detected via loop 
    exp2 = list()
    # e = unique(exp$Species)[1]
    for(e in unique(exp$Species)){ # repeat for each species
      
      # select the relevant landscapes
      b = unique(caps$Landscape[caps$Species == e])
      #and make it a dataframe
      a = data.frame("Landscape" = unique(caps$Landscape[!caps$Landscape %in% b]))
      
      # save species name and make it a no
      a$Species = e
      a$presence = "no"
      
      exp2[[e]] = a
      
    }
    rm(a, b, e)
    
    # combine list into a df
    exp2 = do.call(rbind, exp2)
    rownames(exp2)= NULL
    
    # rbind presence w/ absences
    exp = rbind(exp, exp2)
    rm(exp2)
    
    ## grab all landscapes where neither species was detected
    non_det_land <- exp %>%
      group_by(Landscape) %>%
      filter(all(presence == "no"))
    
    ## extract all the sampling unit names from these landscapes
    non_det_SU = meta$cell_id_3km[meta$Landscape %in% unique(non_det_land$Landscape)]
    
    ## extract both count matricies
    data.dom<- sp_dom_dat$y #dominant
    data.sub<- sp_sub_dat$y #subordinate
    
    ## and thin both to remove empty SUs
    data.dom = data.dom[!data.dom$SU %in% non_det_SU,]
    data.sub = data.sub[!data.sub$SU %in% non_det_SU,]
    
    ## make sure we match! 
    if(nrow(data.dom) != nrow(data.sub)){
      
      # if we dont, let us know
      print(paste("The species combo of", sp_sub, "~", sp_dom, 
                  "have different sized matricies! This pair was skipped."))
      # and skip the probelmatic one
      next
      
    } # end exact matrix size validation
    
    ### Now verify that both species are detected together in at least one landscape
    pres = unique(exp$Landscape[exp$presence == "yes" & exp$Species == unique(exp$Species)[1] &
                                  exp$Landscape %in% exp$Landscape[exp$presence == "yes" & 
                                                                     exp$Species ==  unique(exp$Species)[2]]])
    ## if there are no landscapes where both are detected,
    if(length(pres) == 0){
      
      ## let us know 
      print(paste("The species combo of", sp_sub, "~", sp_dom, 
                  "do not spatially overlap! This pair was skipped."))
      ## and skip the problematic one
      next
      
    }

    
    ## convert matrix dataframes back to matrix 
    rownames(data.dom)=data.dom[,1] #set rownames as sampling units
    data.dom=data.dom[,-1] #remove sampling unit col
    data.dom=as.matrix(data.dom) #turn into a matrix
    # repeat for spp 2
    rownames(data.sub)=data.sub[,1]
    data.sub=data.sub[,-1]
    data.sub=as.matrix(data.sub)
    
    #
    ##
    ###
    #### Site-level covairtes
    ###
    ##
    #

    # Make sure we have the same number of sampling units
    if(dim(sp_dom_dat$siteCovs)[1] != dim(sp_sub_dat$siteCovs)[1]){
      
       # if we dont, let us know
      print(paste("The species combo of", sp_sub, "~", sp_dom, 
                  "have a different number of sampling units! This pair was skipped."))
      # and skip the probelmatic one
      next
     
    }else{
      
      # thin to match relevant sampling units
      covs = sp_dom_dat$siteCovs[sp_dom_dat$siteCovs$cell_id_3km %in% rownames(data.dom),]
      
    } # end cov size conditional 

    
    ### Add conditional if no sites match each other
    if(dim(covs)[1] == 0){
      print(paste0(sp_dom, " & ", sp_sub, " dont spatially overlap, no combo created."))
      next
    }# end lack of spatial overlap bypass  
    
    
    #Extract Landscape for random effect, stored as a number
    d = data.frame("Landscape"= sort(unique(covs$Landscape)),
                   "land.num" = seq(from = 1, to = length(unique(covs$Landscape))))
    covs = merge(covs, d, by = "Landscape")

    #Extract years for random effect, stored as a number
    d = data.frame("year"= sort(unique(covs$year)),
                   "year.num" = seq(from = 1, to = length(unique(covs$year))))
    covs = merge(covs, d, by = "year")

     #Extract data source for random effect, stored as a number
    d = data.frame("source"= sort(unique(covs$source)),
                   "source.num" = seq(from = 1, to = length(unique(covs$source))))
    covs = merge(covs, d, by = "source")
    rm(d)
    
    
    ## Make sure covs match order of matrix
    covs = covs[order(match(covs$cell_id_3km, rownames(data.dom))),]
    
    #verify
    # match(covs$cell_id_3km, rownames(data.dom))
    
    #
    ##
    ###
    #### Observation-level covariates
    ###
    ##
    #
    
    # Make sure we have the same sampling units!
    if(length(setdiff(sp_dom_dat$ObsCovs$SU, sp_sub_dat$ObsCovs$SU)) == 0 &
       length(setdiff(sp_sub_dat$ObsCovs$SU, sp_dom_dat$ObsCovs$SU)) == 0){
      
      ## thin obs down to relevant SUs
      obs = sp_dom_dat$ObsCovs[sp_dom_dat$ObsCovs$SU %in% rownames(data.dom),]
      
      ## and convert to a matrix 
      rownames(obs)=obs[,1] #set rownames as sampling units
      obs=obs[,-1] #remove sampling unit col
      obs=as.matrix(obs) #turn into a matrix, but only keep one 
      
    }else{
      
      ## if obs SUs dont match, let us know! 
      print(paste("The species combo of", sp_sub, "~", sp_dom, 
                "have a different number of sampling units in ObsCovs! This pair was skipped."))
      # and skip the probelmatic one
      next
    }
    
    ## Ensure obs matches the order of matrix 
    obs = obs[order(match(rownames(obs), rownames(data.dom))),]
    # #verify
    # match(rownames(obs), rownames(data.dom))
    
    #
    ##
    ###
    ####
    ##### Prepare the informed ZIP parameters
    ####
    ###
    ##
    #
    
    ## Establish which sites have extirpated dominant species
    
    # first get max number of counts per row
    p = apply(data.dom, 1, max, na.rm = TRUE)
    
    # subset for only sampling units with detections
    p = names(p[p >= 1])
    
    ### Add conditional if no sites match each other
    if(length(p) == 0){
      print(paste0(sp1, " & ", sp2, " may spatially overlap, but were never detected in the same landscape"))
      next
    }# end lack of spatial overlap bypass  
    
    # gather all sampling units in the Landscapes where there were detections
    c = select(covs, cell_id_3km, Landscape)
    d = c[c$cell_id_3km %in% p,]
    d = c[c$Landscape %in% d$Landscape, ]
    
    # gather all sites in landscapes without ANY detections
    e = c[!c$Landscape %in% d$Landscape,]
    
    # this should match number of rows in matrix 
    if((length(e$cell_id_3km) + length(d$cell_id_3km)) != dim(data.dom)[1] &
      (length(e$cell_id_3km) + length(d$cell_id_3km)) != dim(data.sub)[1]){
      
      print(paste0("problem with ", sp_dom, " & ", sp_sub))
      
    } # end data check 
    
    ## Add if-else statment for dominant species not extirpated anywhere. 
    if(length(e$cell_id_3km) > 0){
      
      # combine, where 0 = extirpated, and 1 = present. 
      z.dom = rbind(data.frame("occu" = 0, "cell_id_3km" = e$cell_id_3km),
                    data.frame("occu" = 1, "cell_id_3km" = d$cell_id_3km))
      
    }else{
      
      z.dom = data.frame("occu" = 1, "cell_id_3km" = d$cell_id_3km)
      
    } # end no extirpation conditional 
    
    # make sure its in the same order as the matrix
    z.dom = z.dom[order(match(z.dom$cell_id_3km, rownames(data.dom))),]
    
    
    ## Establish which sites have extirpated subordianate species-
    
    # first get max number of counts per row
    p = apply(data.sub, 1, max, na.rm = TRUE)
    
    # subset for only sites with detections
    p = names(p[p >= 1])
    
    ### Add conditional if no sites match each other
    if(length(p) == 0){
      print(paste0(sp1, " & ", sp2, " may spatially overlap, but were never detected in the same landscape"))
      next
    }# end lack of spatial overlap bypass  
    
    # gather all sites in the landscapes where there were detections
    c = select(covs, cell_id_3km, Landscape)
    d = c[c$cell_id_3km %in% p,]
    d = c[c$Landscape %in% d$Landscape, ]
    
    # gather all sites in landscapes without ANY detections
    e = c[!c$Landscape %in% d$Landscape,]

    # this should match number of rows in matrix 
    if((length(e$cell_id_3km) + length(d$cell_id_3km)) != dim(data.dom)[1] &
       (length(e$cell_id_3km) + length(d$cell_id_3km)) != dim(data.sub)[1]){
      
      print(paste0("problem with ", sp1, " & ", sp2))
      
    } # end data check 
    
    # combine, where 0 = extirpated, and 1 = present. 
    ## Add if-else statment for subordinate species not extirpated anywhere. 
    if(length(e$cell_id_3km) > 0){
      
      z.sub = rbind(data.frame("occu" = 0, "cell_id_3km" = e$cell_id_3km),
                    data.frame("occu" = 1, "cell_id_3km" = d$cell_id_3km))
      
    }else{
      
      z.sub = data.frame("occu" = 1, "cell_id_3km" = d$cell_id_3km)
    } # end no extirpation conditional 
    
    # make sure its in the same order as the matrix
    z.sub = z.sub[order(match(z.sub$cell_id_3km, rownames(data.sub))),]
    
    rm(c,d,e,p)
    
    ####### BUNDLE all the data for the bayesian model 
    
    #these are the variable names used in the bayes mod! 
    bdata = list(y.dom = data.dom,                           # Count history matrix for dominant spp
                 y.sub = data.sub,                           # Count history matrix for subordinate spp
                 Z.dom = z.dom$occu,                         # Dominant presence/absence for all sites
                 Z.sub = z.sub$occu,                         # Subordinate presence/absence for all sites 
                 nsites = dim(data.dom)[1],                  # Number of sampling locations (i.e. rows in matrix)
                 nreps = dim(data.dom)[2],                   # Number of sampling occasions (i.e. cols in matrix)
                 flii = covs$Avg_FLLI_3km,                   # Site covaraite 1
                 hfp = covs$Avg_human_footprint_3km,         # Site covaraite 2
                 elev = covs$Avg_altitude_3km,               # Site covaraite 3
                 hunt = covs$Avg_hunting_accessibility_3km,  # Site covariate 4
                 cams = obs,                                 # Observation covaraite 1
                 narea = length(unique(covs$land.num)),      # number of levels in landscape RE
                 area = covs$land.num,                       # Landscape random effect (as.num)
                 nsource = length(unique(covs$source)),      # number of levels in source RE 
                 source = covs$source.num,                   # Data source random effect (as.num)
                 nyear = length(unique(covs$year.num)),      # number of levels in year RE
                 year = covs$year.num)                       # year random effect (as.num)
    
    ## save the bundle 
    temp[[l]] = bdata
    names(temp)[l] = paste("SUB-", sp_sub, "~DOM-",sp_dom, sep = "" )
    
  } # end 2nd species
  
  ## remove null values in list for species combos that dont overlap 
  temp[sapply(temp, is.null)] <- NULL
  
  ## save all results for all species
  bdata_list[[i]] = temp
  
  
} # end 1st species
rm(i,l,sp_dom,sp_sub, sp_dom_dat, sp_sub_dat, obs, temp, z.dom, z.sub,
   bdata, all_else, data.dom, data.sub, covs, exp, non_det_SU, dom_tg, non_det_land)


## flatten the list of lists into a single list
bdata_list = unlist(bdata_list, recursive = FALSE)
length(bdata_list) #260 combos after removing species that have less than 100 detections in shared landscapes and reducing nonsense species --> Nice! should allow faster testing as we reduce species. 
names(bdata_list) # looks good! 

```

### Save the final list of bundled data

Now that all species pairs are established, the data is properly formatted, and everything is clean, its time to save the data! We will send it to the HPC to run on the R script called: data/HPC_code/HPC_co-abundance_model.R

```{r save bundled data!, echo=FALSE}

## grab today's date 
day<-str_sub(Sys.Date(),-2)
month<-str_sub(Sys.Date(),-5,-4)
year<-str_sub(Sys.Date(),-10,-7)
date = paste(year,month,day, sep = "")
rm(day,month,year)
 
# saveRDS(bdata_list, here::here(paste("data/send_to_HPC/Bundled_data_for_Bayes_co-abundance_mods_", length(bdata_list), "_species_pairs_", date, ".RDS", sep = "")))


```


### Generate data bundles for sensetivity testing

After some preliminary tests, some species pairs are generating wild species interaction values (SIV), such as |5|, or are consistently failing to preform in terms of Bayes p-values. The goal here is to grab at least three species pairs, and play with the data to explore how SIVs and bayes p-vales change based on the underlying data. These three models will include-
1) poor SIV & bayes p-value and rare: "SUB-Lophura_ignita~DOM-Panthera_pardus"  (the inverse, SUB = leopard, is also crazy) (both < 1000 detections)
Other options--

SUB-Trichys_fasciculata~DOM-Panthera_tigris (just over 100 shared detections)
SUB-Macaca_fascicularis~DOM-Cuon_alpinus (< 100 shared detections each)




2) good SIV & bayes p-value and common (and supports a hypothesis): "SUB-Muntiacus_genus~DOM-Panthera_tigris" (both > 1000 detections)

Seems like a mismatch between sample sizes (one really common, one rare), or both rare species tend to produce issues, tho this is not always the case! 

```{r generate testing bundles, echo=FALSE}

# # how many detections for probelm species? Added a few additional problem critters, but wont explore further. 
# sp_count = ddply(caps[caps$Species %in% c("Lophura_ignita","Muntiacus_genus", "Herpestes_brachyurus", "Trichys_fasciculata",
#                                           "Panthera_tigris", "Panthera_pardus", "Cuon_alpinus", "Neofelis_genus"),], .(Species), summarize,
#                  num_cap = length(Species),
#                  num_lands = length(unique(Landscape)))
# sp_count
# 
# 
# ## Create a vector of conditions that will be met when making bundled data. 
# conditions = c("2x_SUB", "2x_DOM", # multiple counts by two
#                "8x_SUB", "8x_DOM", # multiple counts by eight
#                "2/SUB", "2/DOM",   # subtract counts by two 
#                "8/SUB", "8/DOM"    # subtract counts by two 
#                )
# 
# ## save the relevant species pairs 
# pairs = c("SUB-Lophura_ignita~DOM-Panthera_pardus", "SUB-Muntiacus_genus~DOM-Panthera_tigris")
# 
# ## just double check which landscapes BOTH species are detected at. 
# leo_lands = unique(caps$Lanscape[caps$Species == "Panthera_pardus"]) 
# bird_lands = unique(caps$Landscape[caps$Species == "Lophura_ignita"]) ## this isnt supposed to overlap w/ leopards... 
# unique(caps$survey_id[caps$Species == "Lophura_ignita" &
#                         grepl("P_", caps$Landscape)]) # four surveys @ pasoh
# nrow(caps[caps$Species == "Lophura_ignita" &
#                         grepl("P_", caps$Landscape),]) #12 detections! 
# 
# 
# 
# other_lands = unique(caps$Landscape[caps$Species == "Trichys_fasciculata"]) ## IUCN says this isnt in thailand... 
# 
# unique(caps$survey_id[caps$Species == "Trichys_fasciculata" &
#                         grepl("Thai", caps$Landscape)]) # two surveys
# nrow(caps[caps$Species == "Trichys_fasciculata" &
#                         grepl("Thai", caps$Landscape),]) # 16 detections! 
# 
# 
# 
# # Trichys_fasciculata

```

