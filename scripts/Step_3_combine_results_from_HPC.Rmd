---
title: "Step 3 combine results from HPC"
author: "Zachary Amir"
date: "`r Sys.time()`"
output: html_document
---

```{r global-options, include=FALSE, warning=FALSE, error=FALSE}
## We can knit this into a nice document! but dont include all the code unless otherwise specified (i.e. include=TRUE)
knitr::opts_chunk$set(include=FALSE, warning=FALSE, error = FALSE)

## start fresh
rm(list = ls())

## load libraries
library(tidyverse)        ## For basic data wrangling

```

## Introduction

This R Markdown file is used to bring together all of the results generated from the High Performance Computer [(HPC)](https://rcc.uq.edu.au/systems/high-performance-computing/bunya) that will then be saved as combined spreadsheets saved to dropbox. Some of the basic numeric results will be included in this markdown, but all of the data visualization will be left for the 4th and final step of this analysis. 

As a reminder, the co-abundance models were implemented on this R script: scripts/HPC_code/HPC_co-abundance_model_final.R. However, the each JAGS model with long MCMC settings is too heavy to download (*i.e.*, several GB per model), so we only saved spreadsheets from the model on the HPC. 

```{r import legacy data}

## this is the data that was used to create data bundles. Will be useful for comparisons later

## set WD to dropbox where the data lives
wd = paste("/Users/zachary_amir/Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/")

## Import clean cam trap data here for referencing
og_resamp_captures = read.csv(paste(wd,
                          "data/step1_output/clean_captures_to_make_UMFs_5km_scale_20240928.csv", sep = ""))

og_resamp_meta = read.csv(paste(wd,
                          "data/step1_output/clean_metadata_to_make_UMFs_5km_scale_20240928.csv", sep = ""))

### Maybe we want non-resampled data as well??
# og_captures = read.csv("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step4_output_pre-resampling/Clean_independent_captures_20230610.csv")
# og_meta = read.csv("/Users/zachary_amir/Dropbox/CT capture histories database/Asian ECL raw CT data/Step4_output_pre-resampling/Clean_independent_metadata_20230610.csv")

#
##
### Import bundled co-abundance data 

## first, I will import the bundled data to generate a vector of relevant species pairs 
# but since I split the bundled data into multiple files, I must import them all. 
files = list.files(paste(wd,"data/step2_output_CoA_bundles/", sep = ""))
files = files[grepl("Bundled", files)]
files = files[!grepl("MISSING", files)] # avoid reading in repeated data 

# import them all
res = list()
for(i in 1:length(files)){
  
  # import
  b = readRDS(paste(wd, "data/step2_output_CoA_bundles/", files[i], sep = ""))
  
  # and save
  res[[i]] = b
  
  # #### CHECK FOR FAILED MODS 
  # check = preform$Species_Pair[is.na(preform$Interaction_Estimate) & preform$preference == "preferred"]
  # if(any(names(b) %in% check)){
  #   ## grab the match 
  #   sp = check[check %in% names(b)]
  #   ## print the message
  #   print(paste("The species pairs:", paste(sp, collapse = " & "), "are in file name:", files[i]))
  #   for(s in 1:length(sp)){
  #     p = sp[s]
  #     pos = which(names(b) %in% p)
  #     print(paste("Specifically, species pair:", p, "is located in this bundle at position:", pos))
  #   }
  # }
  
}
rm(b,i)

## combine them into a single list by unlisting the list 
bdata = unlist(res, recursive = F)
rm(res)

## save vector of relevant species pairs
all_combos = names(bdata)


```

```{r import coefficent dataframes}

# First, list all result files
files = list.files(paste(wd, "results/", sep = ""), recursive = T)
# We dont want OE files (that informed GB requirements)
files = files[!grepl("OE", files)]
files = files[!grepl("counterfactual1|counterfactual2|counterfactual3|counterfactual4|counterfactual5|counterfactual6|counterfactual7", files)]

## specify the MCMC setting were interested in 
setting = "LONG"

## Specify the spatial scale we are interested in 
scale = "5km"

## Specify the specific iteration of tests were interested in
# options are "Jan_2024", "Sep_2024" "Oct2024", and "Dec2024"
time = "Dec2024"

# Subset for the MCMC settings were interested in 
files = files[grepl(setting, files)]
# and same for spatial scale
files = files[grepl(scale, files)]
# and for the same time period
files = files[grepl(time, files)]

# Grab all coefficent dataframe files
files = files[grepl("/coefficent_dataframes/", files)]

## since we have reduced the number of viable species pairs w/ the detection ratio
# thin files to the relevant combos in all_combos

# Extract species pairs from the filenames in `files`
sp_pair = sub(".*coefficents_(SUB-.*DOM-.*)_\\d{8}\\.csv$", "\\1", files)

# Thin the `files` vector by keeping only those that match `all_combos`
files = files[sp_pair %in% all_combos]
rm(sp_pair)

# store results here
coeff.res = list()

# loop thru each file to import into list
for(i in 1:length(files)){
  
  ## grab the matching species pair here
  match = all_combos[sapply(all_combos, grepl, x = files[i])]
  ## verify there are no repeats here
  res_search = files[grepl(match, files)]
  ## if there are indeed repeats 
  if(length(res_search) > 1){
    # Extract the date using a regular expression
    dates = sub(".*_(\\d{8})\\.csv$", "\\1", res_search)
    # Order the filenames based on the extracted dates (from most recent to least recent)
    res_search = res_search[order(dates, decreasing = TRUE)]
    # and take the most recent file
    file = res_search[1]
  }else{
    # but if only one, just overwrite file to be the correct one
    file = files[i]
  }# end multiple file conditon

  # import 
  d = read.csv(paste(wd, "results/", file, sep = ""))
  
  ## if there are pesky row.names, remove em!
  d$X = NULL
  
  ## And dont forget to add the MCMC settings
  d$MCMC_setting = setting
  
  coeff.res[[i]] = d
  
  if(ncol(d) != 11){
    print(paste("The file", files[i], "with the index value of", i, 
                "has the wrong number of columns and wont combine well. INVESTIGTE!"))
  }
}
rm(d,i, files, file)

## bind together and inspect
coeff = distinct(do.call(rbind, coeff.res))

## quick inspection
str(coeff)
rm(coeff.res)

## split apart species pair into sub vs dom species
coeff <- within(coeff, {
  sub_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[1])
  dom_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[2])
})
coeff$dom_sp = gsub("DOM-", "", coeff$dom_sp)
coeff$sub_sp = gsub("SUB-", "", coeff$sub_sp)


### Inspect which species pairs are present/missing, 20250124, LONG settings
setdiff(all_combos, coeff$Species_Pair) 
## 4 models missing --> currently running on HPC. 

# save the missing mods 
missing = setdiff(all_combos, coeff$Species_Pair)
# 2024-12-20 w/ new comm_det variable, dont compare old mods 
missing = c()

#
##
###
#### Make this a conditional statement when there are no more missing mods 
###
##
#

if(length(missing)>0){
  
  # First, list all result files
  files = list.files(paste(wd, "results/", sep = ""), recursive = T)
  # We dont want OE files (that informed GB requirements)
  files = files[!grepl("OE", files)]
  files = files[!grepl("counterfactual2|counterfactual3|counterfactual4|counterfactual5|counterfactual6|counterfactual7", files)]
  
  ## specify the MCMC setting were interested in 
  setting = "MIDDLE"
  
  # Subset for the MCMC settings were interested in 
  files = files[grepl(setting, files)]
  # and same for spatial scale
  files = files[grepl(scale, files)]
  
  # Grab all coefficent dataframe files
  files = files[grepl("/coefficent_dataframes/", files)]
  
  # and make sure were only importing the relevant sp pairs
  files = files[grepl(paste(missing, collapse = "|"), files)]
  
  ## make sure files is present! 
  if(length(files) > 0){
    # store results here
  coeff.res = list()
  
  # loop thru each file to import into list
  for(i in 1:length(files)){
    
    # import 
    d = read.csv(paste(wd, "results/", files[i], sep = ""))
    
    ## if there are pesky row.names, remove em!
    d$X = NULL
    
    ## And dont forget to add the MCMC settings
    d$MCMC_setting = setting
    
    coeff.res[[i]] = d
    
    if(ncol(d) != 11){
      print(paste("The file", files[i], "with the index value of", i, 
                  "has the wrong number of columns and wont combine well. INVESTIGTE!"))
    }
  }
  rm(d,i, files)
  
  ## bind together and inspect
  coeff2 = do.call(rbind, coeff.res)
  rm(coeff.res)
  
  ## split apart species pair into sub vs dom species
  coeff2 <- within(coeff2, {
    sub_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[1])
    dom_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[2])
  })
  coeff2$dom_sp = gsub("DOM-", "", coeff2$dom_sp)
  coeff2$sub_sp = gsub("SUB-", "", coeff2$sub_sp)
  
  ## Thin to only the missing models 
  coeff2 = coeff2[coeff2$Species_Pair %in% missing, ]
  
  ## and combine! 
  coeff = rbind(coeff, coeff2)
  rm(coeff2)
  } # end file length condition
  
  ## verify were all here now 
  setdiff(all_combos, coeff$Species_Pair)
  ## 20241021 --> middle only had preferred results! Still missing 84 mods :(, but all preferred mods are here, which is most important! 
  ## 20241209 --> still missing two b/c they were in community, not preferred, mods. 
}

## keep enviro clean! 
rm(missing, setting)



```

```{r Create dataframe to track preformance}

## create a dataframe to track our model performance
preform = data.frame("Species_Pair" = all_combos,
                     "sub_species" = as.character(NA),
                     "dom_species" = as.character(NA))

## add individual species to individual cols via loop 
for(i in 1:length(preform$Species_Pair)){
  
  ## gather the combo and split it 
  c = preform$Species_Pair[i]
  c = str_split(c, "~")
  
  ## add it to the DF
  preform$sub_species[i] = c[[1]][1]
  preform$dom_species[i] = c[[1]][2]
  
  ## clean it up
  preform$sub_species[i] = gsub("SUB-", "", preform$sub_species[i])
  preform$dom_species[i] = gsub("DOM-", "", preform$dom_species[i])
  
}
rm(c,i)

## inspect
anyNA(preform) # Must be F

## assess which models are completed
preform$mod_completion = "uncompleted"
preform$mod_completion[preform$Species_Pair %in% coeff$Species_Pair] = "completed"
table(preform$mod_completion) 
## Oct 21, 2024, Long @ 5km
# completed = 178
# uncompleted = 84

## December 9th, 2024, Long @ 5 km w/ community
# completed = 260
# uncompleted = 2 (community mods) --> sent to re-run on HPC

## December 20th, 2024, Long @ 5km w/ comm_det
# completed = 67 (preferred)
# uncompleted = 195 (community mods) --> sent to re-run on HPC

## January 9th, 2025, Long @ 5km w/ comm_det
# completed = 253 
# uncompleted = 9



```

```{r Import PPC dataframes}

# First, list all result files
files = list.files(paste(wd, "results/", sep = ""), recursive = T)
# We dont want OE files (that informed GB requirements) or counter-factuals
files = files[!grepl("OE", files)]
files = files[!grepl("counterfactual1|counterfactual2|counterfactual3|counterfactual4|counterfactual5|counterfactual6|counterfactual7", files)]

## specify the MCMC setting were interested in 
setting = "LONG"

# Subset for the MCMC settings were interested in 
files = files[grepl(setting, files)]
# and same for spatial scale
files = files[grepl(scale, files)]
# and same time frame
files = files[grepl(time, files)]

# Grab all PPC_dataframe files
files = files[grepl("/PPC_dataframes/", files)]
# and dont want plotting data 
files = files[!grepl("plotdata", files)] 

## since we have reduced the number of viable species pairs w/ the detection ratio
# thin files to the relevant combos in all_combos

# Extract species pairs from the filenames in `files`
sp_pair = sub(".*BPV_and_Chat_values_(SUB-.*DOM-.*)_\\d{8}\\.csv$", "\\1", files)

# Thin the `files` vector by keeping only those that match `all_combos`
files = files[sp_pair %in% all_combos]
rm(sp_pair)

# store results here
ppc_res = list()

# loop thru each file to import into list
for(i in 1:length(files)){
  
  ## grab the matching species pair here
  match = all_combos[sapply(all_combos, grepl, x = files[i])]
  ## verify there are no repeats here
  res_search = files[grepl(match, files)]
  ## if there are indeed repeats 
  if(length(res_search) > 1){
    # Extract the date using a regular expression
    dates = sub(".*_(\\d{8})\\.csv$", "\\1", res_search)
    # Order the filenames based on the extracted dates (from most recent to least recent)
    res_search = res_search[order(dates, decreasing = TRUE)]
    # and take the most recent file
    file = res_search[1]
  }else{
    # but if only one, just overwrite file to be the correct one
    file = files[i]
  }# end multiple file conditon
  
  ## read the file 
  d = read.csv(paste(wd, "results/", file, sep = ""))
  
  ## add the MCMC setting
  d$MCMC_setting = setting
  
  ## save plotdata vs values in nested list. 
  if(grepl("plotdata", files[i])){
    
    ppc_res$plotdata[[i]] = d
    
  }else{
    
    ppc_res$values[[i]] = d
    
  } # end plot vs value condition
  
}
rm(d,i, files, file)

# ## bind together and inspect
# ppc_plotdat = do.call(rbind, ppc_res$plotdata)
# head(ppc_plotdat) 

## bind together and inspect
ppc_values = distinct(do.call(rbind, ppc_res$values))
str(ppc_values) # looks mostly good! 
ppc_values$X = NULL # damn row names 


### Inspect which species pairs are present/missing, 20241220, LONG settings
setdiff(all_combos, ppc_values$Species_Pair) 
## 193 mods missing, mostly community 

# save the missing mods 
missing = setdiff(all_combos, ppc_values$Species_Pair)
# 2024-12-20 w/ new comm_det variable, dont compare old mods 
missing = c()

#
##
###
#### Make this a conditional statement when there are no more missing mods 
###
##
#

if(length(missing)>0){
  
  # First, list all result files
  files = list.files(paste(wd, "results/", sep = ""), recursive = T)
  # We dont want OE files (that informed GB requirements) or counter-factuals
  files = files[!grepl("OE", files)]
  files = files[!grepl("counterfactual2|counterfactual3|counterfactual4|counterfactual5|counterfactual6", files)]
  
  ## specify the MCMC setting were interested in 
  setting = "MIDDLE"
  
  # Subset for the MCMC settings were interested in 
  files = files[grepl(setting, files)]
  # and same for spatial scale
  files = files[grepl(scale, files)]
  
  # Grab all PPC_dataframe files
  files = files[grepl("/PPC_dataframes/", files)]
  # and dont want plotting data 
  files = files[!grepl("plotdata", files)] 
  
  # and make sure were only importing the relevant sp pairs
  files = files[grepl(paste(missing, collapse = "|"), files)]
  
  # make sure files are present! 
  if(length(files) > 0){
    # store results here
  ppc_res = list()
  
  # loop thru each file to import into list
  for(i in 1:length(files)){
    
    ## read the file 
    d = read.csv(paste(wd, "results/", files[i], sep = ""))
    
    ## add the MCMC setting
    d$MCMC_setting = setting
    
    ## save plotdata vs values in nested list. 
    if(grepl("plotdata", files[i])){
      
    ppc_res$plotdata[[i]] = d
    
  }else{
    
    ppc_res$values[[i]] = d
    
  } # end plot vs value condition
  
}
rm(d,i, files)

## bind together and inspect
ppc2 = do.call(rbind, ppc_res$values)
ppc2$X = NULL # damn row names 

## and combine! 
ppc_values = rbind(ppc_values, ppc2)
rm(ppc2)

  } # end file length condition
  
## verify were all here now 
setdiff(all_combos, coeff$Species_Pair)
## 20241021 --> middle only had preferred results! Still missing 84 mods :(, but all preferred mods are here, which is most important! 
}

## keep enviro clean! 
rm(missing, setting, ppc_res)

```

```{r Import trait data and add to preformance dataframe}

#load guild data
guilds = read.csv(paste(wd, "data/step1_output/clean_44_species_trait_data_20240928.csv", sep = ""))
str(guilds)
## looks good, dietary preferences are ready to go! 

#
##
### Combine species trait/guild data w/ model performance

## make sure all species are present
setdiff(preform$sub_species, guilds$scientificNameStd) # these match, add subordinate guild first

add = select(guilds, scientificNameStd, TrophicGuild)
names(add) = c("sub_species", "SUB_guild")

preform = merge(preform, add, by = "sub_species")
head(preform)

## now do the same for dominant speices
setdiff(preform$dom_species, guilds$scientificNameStd) # these match
add = select(guilds, scientificNameStd, TrophicGuild)
names(add) = c("dom_species", "DOM_guild")

preform = merge(preform, add, by = "dom_species")
head(preform)

## combine into a guild pair 
preform$guild_pair = paste("SUB-", preform$SUB_guild, "~",
                           "DOM-", preform$DOM_guild, sep = "")
## what can we actually work with rn
table(preform$guild_pair[preform$mod_completion == "completed"]) # a lot!

## clean up 
rm(add)


```

```{r Add data to preformance dataframe to track model validity}

### Will use the preform data.frame (generated in coefficents import), 
## to track which models are robust, working, and converging. 
# Currently this data.frame has no data in it, only descriptors

## inspect data
str(preform) 
# need to add sub + dom BPV/Chat & species interaction, its significance, and the Rhat value

### inspect available data 
str(ppc_values) # its all here! 

## merge it! 
preform = merge(preform, ppc_values, by = "Species_Pair", all.x = T) # make sure to keep all values from preform b/c some could be missing from PPC! 


## inspect
str(preform) # looks good 
## Check if any are still uncompleted --> will have NA values for BPV,Chat,Rhat,etc
str(preform[preform$mod_completion == "uncompleted",]) #same missing ones from before, re-running on HPC now! 

## Add a column denoting if the BPV values converged based on a wide range to account for many mods 
preform$BPV_valid = "No"
preform$BPV_valid[preform$BPV.dom >= 0.15 & preform$BPV.dom <= 0.85 &
                    preform$BPV.sub >= 0.15 & preform$BPV.sub <= 0.85] = "Yes"
table(preform$BPV_valid[!is.na(preform$Interaction_Estimate)]) 
# majority are valid 

## Add another column that is a more conservative BPV interpretation --> same as co-abundance MS 
preform$BPV_valid_conserv = "No"
preform$BPV_valid_conserv[preform$BPV.dom >= 0.25 & preform$BPV.dom <= 0.75 &
                            preform$BPV.sub >= 0.25 & preform$BPV.sub <= 0.75] = "Yes"
table(preform$BPV_valid_conserv[!is.na(preform$Interaction_Estimate)]) # No is the majority

## add a column denoting if over dispersion remains with a wide range to account for many mods 
preform$OD_valid = "No"
preform$OD_valid[preform$Chat.dom >= 0.95 & preform$Chat.dom <= 1.3 &
                     preform$Chat.sub >= 0.95 & preform$Chat.sub <= 1.3] = "Yes"
table(preform$OD_valid[!is.na(preform$Interaction_Estimate)]) 
## all are good! 
## I bet this is because active_cams + RE for source are actually good for detection models... less reliance on ODRE

## Add another column for a more conservative OD parameter --> same as co-abundance MS
preform$OD_valid_conserv = "No"
preform$OD_valid_conserv[preform$Chat.dom >= 0.98 & preform$Chat.dom <= 1.1 &
                           preform$Chat.sub >= 0.98 & preform$Chat.sub <= 1.1] = "Yes"
table(preform$OD_valid_conserv[!is.na(preform$Interaction_Estimate)]) # only 2 failed 


## add a column denoting if the species interaction parameter converged 
preform$parameter_valid = "No"
preform$parameter_valid[preform$Rhat >= 0.99 & preform$Rhat <= 1.2] = "Yes"
table(preform$parameter_valid[!is.na(preform$Interaction_Estimate)]) # majority is valid!

## Add the direction of the relationship
preform$direction[preform$sub_species %in% c("Panthera_tigris", "Panthera_pardus", 
                                             "Neofelis_genus", "Cuon_alpinus")] = "bottom-up"
preform$direction[preform$dom_species %in% c("Panthera_tigris", "Panthera_pardus", 
                                             "Neofelis_genus", "Cuon_alpinus")] = "top-down" # this should allow large carnivore pairings to be top-down
## Check all large carnivore pairings are top-down
unique(preform$direction[preform$guild_pair == "SUB-Large_Carnivore~DOM-Large_Carnivore"]) #  good! 

## add a column to preform to determine if the model is a preferred prey species or not
preform$preference = "community"
# top-downs
preform$preference[preform$dom_sp == "Panthera_tigris" & preform$sub_sp %in% guilds$scientificNameStd[guilds$tiger_pref == "Yes"]] = "preferred"
preform$preference[preform$dom_sp == "Panthera_pardus" & preform$sub_sp %in% guilds$scientificNameStd[guilds$leopard_pref == "Yes"]] = "preferred"
preform$preference[preform$dom_sp == "Neofelis_genus" & preform$sub_sp %in% guilds$scientificNameStd[guilds$CL_pref == "Yes"]] = "preferred"
preform$preference[preform$dom_sp == "Cuon_alpinus" & preform$sub_sp %in% guilds$scientificNameStd[guilds$dhole_pref == "Yes"]] = "preferred"
# bottoms-up
preform$preference[preform$sub_sp == "Panthera_tigris" & preform$dom_sp %in% guilds$scientificNameStd[guilds$tiger_pref == "Yes"]] = "preferred"
preform$preference[preform$sub_sp == "Panthera_pardus" & preform$dom_sp %in% guilds$scientificNameStd[guilds$leopard_pref == "Yes"]] = "preferred"
preform$preference[preform$sub_sp == "Neofelis_genus" & preform$dom_sp %in% guilds$scientificNameStd[guilds$CL_pref == "Yes"]] = "preferred"
preform$preference[preform$sub_sp == "Cuon_alpinus" & preform$dom_sp %in% guilds$scientificNameStd[guilds$dhole_pref == "Yes"]] = "preferred"
## how many do we have?
table(preform$preference) # 66 preferred, 125 not. 66 + 125 = 191 -> know were missing! 

## are all preferred models finished?
anyNA(preform$Interaction_Estimate[preform$preference == "preferred"]) # MUST BE F! 
# if true, check who 
preform$Species_Pair[is.na(preform$Interaction_Estimate) & preform$preference == "preferred"]
# 2 mods :(, important ones too. 

## are all community models finished?
anyNA(preform$Interaction_Estimate[preform$preference == "community"]) # MUST BE F! but can proceed before F, just make sure to come back here!


## Assign 3 levels of non-support --> unsupported_1, unsupported_2, unsupported_3
preform$support[preform$BPV_valid == "No" |
                  preform$OD_valid == "No" |
                  preform$parameter_valid == "No"] = "Unsupported_3" # lowest level of support --> bad mod.
preform$support[preform$BPV_valid == "Yes" & 
                  preform$OD_valid == "Yes" &
                  preform$parameter_valid == "Yes" &
                  preform$Significance == "Non-Significant"] = "Unsupported_2" # mid-low support --> good mod, but not important
preform$support[preform$BPV_valid == "Yes" & 
                  preform$OD_valid == "Yes" &
                  preform$parameter_valid == "Yes" &
                  preform$Significance == "Significant" &
                  preform$direction == "top-down" &
                  preform$Interaction_Estimate > 0] = "Unsupported_1" # almost supportive --> good model, significant result, but not in correct direction for hypothesis.  
preform$support[preform$BPV_valid == "Yes" & 
                  preform$OD_valid == "Yes" &
                  preform$parameter_valid == "Yes" &
                  preform$Significance == "Significant" &
                  preform$direction == "bottom-up" &
                  preform$Interaction_Estimate < 0] = "Unsupported_1" # Same as above, but applied for bottom-up direction. 
## assign which models support our hypothesis
preform$support[preform$BPV_valid == "Yes" & 
                  preform$OD_valid == "Yes" &
                  preform$parameter_valid == "Yes" &
                  preform$Significance == "Significant" &
                  preform$direction == "top-down" &
                  preform$Interaction_Estimate <= 0] = "Supported" # good model, significant result, in correct direction for hypothesis.  
preform$support[preform$BPV_valid == "Yes" & 
                  preform$OD_valid == "Yes" &
                  preform$parameter_valid == "Yes" &
                  preform$Significance == "Significant" &
                  preform$direction == "bottom-up" &
                  preform$Interaction_Estimate >= 0] = "Supported" # Same as above, but applied for bottom-up direction. 

## inspect
table(preform$support);anyNA(preform$support) # must be F for NA! 


#### Do the same thing, but with the conservative values
## Assign 3 levels of non-support --> unsupported_1, unsupported_2, unsupported_3
preform$support_conserv[preform$BPV_valid_conserv == "No" |
                          preform$OD_valid_conserv == "No" |
                          preform$parameter_valid == "No"] = "Unsupported_3" # lowest level of support --> bad mod.
preform$support_conserv[preform$BPV_valid_conserv == "Yes" & 
                          preform$OD_valid_conserv == "Yes" &
                          preform$parameter_valid == "Yes" &
                          preform$Significance == "Non-Significant"] = "Unsupported_2" # mid-low support --> good mod, but not important
preform$support_conserv[preform$BPV_valid_conserv == "Yes" & 
                          preform$OD_valid_conserv == "Yes" &
                          preform$parameter_valid == "Yes" &
                          preform$Significance == "Significant" &
                          preform$direction == "top-down" &
                          preform$Interaction_Estimate > 0] = "Unsupported_1" # almost supportive --> good model, significant result, but not in correct direction for hypothesis.  
preform$support_conserv[preform$BPV_valid_conserv == "Yes" & 
                          preform$OD_valid_conserv == "Yes" &
                          preform$parameter_valid == "Yes" &
                          preform$Significance == "Significant" &
                          preform$direction == "bottom-up" &
                          preform$Interaction_Estimate < 0] = "Unsupported_1" # Same as above, but applied for bottom-up direction. 
## assign which models support our hypothesis
preform$support_conserv[preform$BPV_valid_conserv == "Yes" & 
                          preform$OD_valid_conserv == "Yes" &
                          preform$parameter_valid == "Yes" &
                          preform$Significance == "Significant" &
                          preform$direction == "top-down" &
                          preform$Interaction_Estimate <= 0] = "Supported" # good model, significant result, in correct direction for hypothesis.  
preform$support_conserv[preform$BPV_valid_conserv == "Yes" & 
                          preform$OD_valid_conserv == "Yes" &
                          preform$parameter_valid == "Yes" &
                          preform$Significance == "Significant" &
                          preform$direction == "bottom-up" &
                          preform$Interaction_Estimate >= 0] = "Supported" # Same as above, but applied for bottom-up direction. 
## inspect
table(preform$support_conserv[!is.na(preform$Interaction_Estimate)])
anyNA(preform$support[!is.na(preform$Interaction_Estimate)]) # must be F for NA! 



```

## Description of results

A total of `r length(preform$Species_Pair[preform$mod_completion == "completed"])` co-abundance models out of `r length(preform$Species_Pair)` were successfully completed and downloaded from the HPC. The models are composed of **`r length(preform$Species_Pair[preform$preference == "community" & !is.na(preform$Interaction_Estimate)])` 'community models'** across the entire eligible community, and **`r length(preform$Species_Pair[preform$preference == "preferred" & !is.na(preform$Interaction_Estimate)]) ` 'preferred models'** based on large carnivore dietary preferences. There were a total of `r length(preform$Species_Pair[preform$direction == "top-down" & preform$preference == "community"])` community top-down models and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$preference == "preferred"])` preferred top-down models. There were a total of `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$preference == "community"])` community bottom-up models and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$preference == "preferred"])` preferred bottom-up models.

These completed models are composed of `r length(preform$Species_Pair[preform$preference == "preferred" & preform$mod_completion == "completed" & !is.na(preform$Interaction_Estimate)])` preferred models and  `r length(preform$Species_Pair[preform$preference == "community" & preform$mod_completion == "completed"& !is.na(preform$Interaction_Estimate)])` community models. The settings used on the HPC to complete these models are composed of `r length(unique(preform$Species_Pair[preform$MCMC_setting == "LONG" & !is.na(preform$Interaction_Estimate)]))` models with long settings,  `r length(unique(preform$Species_Pair[preform$MCMC_setting == "MIDDLE" & !is.na(preform$Interaction_Estimate)]))` models with middle settings, and  `r length(unique(preform$Species_Pair[preform$MCMC_setting == "SHORT" & !is.na(preform$Interaction_Estimate)]))` models with short settings. 

If there are any __uncompleted preferred models__, the names of those species-pairs will appear here: **`r paste(preform$Species_Pair[is.na(preform$Interaction_Estimate) & preform$preference == "preferred"], collapse = ", ")`**. 

It is important to inspect the diagnostics of the models before we interpret results, and there are four key diagnostic features to inspect. 

1) The first key value we are interested in is the __parameter convergence (known as R-hat) around the species interaction value (SIV)__, where parameters are converged if values are between 1 and 1.2. **The median Rhat for the SIV is `r round(median(preform$Rhat, na.rm = T), 3)` with a standard deviation of `r round(sd(preform$Rhat, na.rm = T), 3)`**. In total, `r length(unique(preform$Species_Pair[preform$parameter_valid == "No"]))` models failed to generate a convergent SIV. This is composed of `r length(unique(preform$Species_Pair[preform$parameter_valid == "No" & preform$preference == "preferred" & !is.na(preform$Interaction_Estimate)]))` preferred models and `r length(unique(preform$Species_Pair[preform$parameter_valid == "No" & preform$preference == "community" & !is.na(preform$Interaction_Estimate)]))` community models.

2) The second key value is the __Bayesian p-value denoting model goodness-of-fit__, where models are deemed to be a good fit if values are between 0.15 to 0.85, with values outside of this range being considered a bad fit. **Across all models `r round(as.numeric(table(preform$BPV_valid[!is.na(preform$Interaction_Estimate)])[1]/ length(preform$Species_Pair[!is.na(preform$Interaction_Estimate)]) * 100), 2)` percent of models are considered a bad fit**. This is composed of `r length(preform$Species_Pair[preform$BPV_valid == "No" & preform$preference == "preferred" &  !is.na(preform$Interaction_Estimate)])` preferred models and `r length(preform$Species_Pair[preform$BPV_valid == "No" & preform$preference == "community" &  !is.na(preform$Interaction_Estimate)])` community models. 

3) The third key value is the __C-hat overdispersion value__, where models are deemed to not have any overdispersion in detections if values are between 0.95 and 1.3. **Across all models `r round(as.numeric(table(preform$OD_valid[!is.na(preform$Interaction_Estimate)])[1]/ length(preform$Species_Pair[!is.na(preform$Interaction_Estimate)]) * 100), 2)` percent of models contain remaining overdispersion of detections not accounted for in the detection formula**. This is composed of `r length(preform$Species_Pair[preform$OD_valid == "No" & preform$preference == "preferred" & !is.na(preform$Interaction_Estimate)])` preferred models and `r length(preform$Species_Pair[preform$OD_valid == "No" & preform$preference == "community" &  !is.na(preform$Interaction_Estimate)])` community models. 

4) The fourth value is __the direction of the SIV based on our hypotheses__, where top-down models should have a significant negative relationship and bottom-up models should have a significant positive relationship. As a reminder, top-down models are when large carnivores are the dominant species and bottom-up models are where large carnivores are the subordinate species. For the preferred top-down models, `r length(preform$Species_Pair[preform$Significance == "Significant" & preform$direction == "top-down" & preform$Interaction_Estimate <= 0 & preform$preference == "preferred" ])` models meet these conditions. For the preferred bottom-up models, `r length(preform$Species_Pair[preform$Significance == "Significant" & preform$direction == "bottom-up" & preform$Interaction_Estimate >= 0 & preform$preference == "preferred" ])` models meet these conditions. For the community top-down models, `r length(preform$Species_Pair[preform$Significance == "Significant" & preform$direction == "top-down" & preform$Interaction_Estimate <= 0 & preform$preference == "community" ])` models meet these conditions. For the community bottom-up models, `r length(preform$Species_Pair[preform$Significance == "Significant" & preform$direction == "bottom-up" & preform$Interaction_Estimate >= 0 & preform$preference == "community" ])` models meet these conditions.

In combining these different diagnostic tools, we can determine different levels of support for our results. Models that had unsuitable parameter convergence or Bayes p-values and remaining over-dispersion are likely due to insufficient data or excessive residual noise from weakly interacting species (Fig. S2, unsupported_3). Models that had insignificant SIVs are likely due to the inclusion of covariates in the model being more informative than species interactions (Fig. S2, unsupported_2). Models with significant SIVs in the opposite direction as we hypothesized are likely due to shared responses to unexplained variation in covariates not included in the model, such as both predator and prey responding negatively to hunting in bottom-up models, or both species responding positively to fruit availability in top-down models (Fig. S2, unsupported_1). Finally, when a model meets all of the previous criteria, then we can determine the model as supported. The resulst from each level are provided below:

1) There were a total of `r length(preform$Species_Pair[preform$support == "Unsupported_3" & !is.na(preform$Interaction_Estimate)])` unsupported_3 models. This is composed of `r length(preform$Species_Pair[preform$support == "Unsupported_3" & !is.na(preform$Interaction_Estimate) & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$support == "Unsupported_3" & !is.na(preform$Interaction_Estimate) & preform$preference == "community"])` community models. 

2) There were a total of `r length(preform$Species_Pair[preform$support == "Unsupported_2" & !is.na(preform$Interaction_Estimate)])` unsupported_2 models. This is composed of `r length(preform$Species_Pair[preform$support == "Unsupported_2" & !is.na(preform$Interaction_Estimate) & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$support == "Unsupported_2" & !is.na(preform$Interaction_Estimate) & preform$preference == "community"])` community models. 

3) There were a total of `r length(preform$Species_Pair[preform$support == "Unsupported_1" & !is.na(preform$Interaction_Estimate)])` unsupported_1 models. This is composed of `r length(preform$Species_Pair[preform$support == "Unsupported_1" & !is.na(preform$Interaction_Estimate) & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$support == "Unsupported_1" & !is.na(preform$Interaction_Estimate) & preform$preference == "community"])` community models. 

4) There were a total of `r length(preform$Species_Pair[preform$support == "Supported" & !is.na(preform$Interaction_Estimate)])` supported models. This is composed of `r length(preform$Species_Pair[preform$support == "Supported" & !is.na(preform$Interaction_Estimate) & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$support == "Supported" & !is.na(preform$Interaction_Estimate) & preform$preference == "community"])` community models. 

In interpreting our supported results, we can split them between top-down and bottom-up results.

* **For the supported top-down results, we had a total of `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported"])` models. This is composed of `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community"])` community models.** __Tigers__ showed `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("tigris", preform$dom_species)])` top-down relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("tigris", preform$dom_species)])` top-down relationships with the overall community. __Leopards__ showed `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("pardus", preform$dom_species)])` top-down relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("pardus", preform$dom_species)])` top-down relationships with the overall community. __Dholes__ showed `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Cuon", preform$dom_species)])` top-down relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("Cuon", preform$dom_species)])` top-down relationships with the overall community. Finally, __clouded leopards__ showed `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Neofelis", preform$dom_species)])` top-down relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("Neofelis", preform$dom_species)])` top-down relationships with the overall community. 

* **For the supported bottom-up results, we had a total of `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported"])` models. This is composed of `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred"])` preferred models and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community"])` community models.** __Tigers__ showed `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("tigris", preform$sub_species)])` bottom-up relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("tigris", preform$sub_species)])` bottom-up relationships with the overall community. __Leopards__ showed `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("pardus", preform$sub_species)])` bottom-up relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("pardus", preform$sub_species)])` bottom-up relationships with the overall community. __Dholes__ showed `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Cuon", preform$sub_species)])` bottom-up relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("Cuon", preform$sub_species)])` bottom-up relationships with the overall community. __Clouded leopards__ showed `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Neofelis", preform$sub_species)])` bottom-up relationships with their preferred prey and `r length(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("Neofelis", preform$sub_species)])` bottom-up relationships with the overall community.

1) __Tigers preferred bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("tigris", preform$sub_species)], sep = ", ")`, and the __preferred top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("tigris", preform$dom_species)], sep = ", ")`. The __community bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("tigris", preform$sub_species)], sep = ", ")`, and the __community top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("tigris", preform$dom_species)], sep = ", ")`. 

2) __Leopards preferred bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("pardus", preform$sub_species)], sep = ", ")`, and the __preferred top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("pardus", preform$dom_species)], sep = ", ")`. The __community bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("pardus", preform$sub_species)], sep = ", ")`, and the __community top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("pardus", preform$dom_species)], sep = ", ")`. 

3) __Dholes preferred bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Cuon", preform$sub_species)], sep = ", ")`, and the __preferred top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Cuon", preform$dom_species)], sep = ", ")`. The __community bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("Cuon", preform$sub_species)], sep = ", ")`, and the __community top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("Cuon", preform$dom_species)], sep = ", ")`. 

4) __Clouded leopards preferred bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Neofelis", preform$sub_species)], sep = ", ")`, and the __preferred top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "preferred" & grepl("Neofelis", preform$dom_species)], sep = ", ")`. The __community bottom-up relationships__ were: `r paste(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported" & preform$preference == "community" & grepl("Neofelis", preform$sub_species)], sep = ", ")`, and the __community top-down relationships__ were: `r paste(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported" & preform$preference == "community" & grepl("Neofelis", preform$dom_species)], sep = ", ")`. 

```{r Inpsect new significant top-down results, eval=FALSE}

## who is who 
preform[preform$direction == "top-down" & 
          preform$preference == "preferred" &
          preform$support == "Supported", ]
## Dhole and bearded pigs are new. And they have a large negative effect size, almost triple the next largest ES 

preform[preform$direction == "top-down" & 
          preform$preference == "preferred" &
          preform$support_conserv == "Supported", ] # dhole is still significant here. 

## inpsect old preform dataframe for results (without new variable)
old_preform = read.csv(paste(wd, "data/step3_output_combined_results/OLD_20241021/compiled_co-abundance_preformance_and_support_dataframe_178_completed_models_20241021.csv", sep = ""))

# check the sp pair 
old_preform[old_preform$Species_Pair == "SUB-Sus_barbatus~DOM-Cuon_alpinus",]
## interaction estimate is much lower at -0.39, but with a SD at 1.4 and a bad Rhat value (14)
preform[preform$Species_Pair == "SUB-Sus_barbatus~DOM-Cuon_alpinus",]
## interaction estimate is -1.3, and the SD is 0.2, and all other checks are fine. 

## inspect the original data 
# dhole detections
dho = og_resamp_captures[og_resamp_captures$Species == "Cuon_alpinus",]
# and bearded pig 
bp = og_resamp_captures[og_resamp_captures$Species == "Sus_barbatus",] # many more detections here
# which landscapes were they both detected at?
bp_land = unique(og_resamp_meta$Landscape[og_resamp_meta$cell_id %in% bp$cell_id])
dho_land = unique(og_resamp_meta$Landscape[og_resamp_meta$cell_id %in% dho$cell_id])
# where do they match?
bp_land[bp_land %in% dho_land] # only kerinci! 

## how many detections of each species at kerinci?
sum(dho$independent_events[grepl("KSNP", dho$cell_id)]) # 4 dhole detections??
sum(bp$independent_events[grepl("KSNP", bp$cell_id)]) # 959 BP detections 
## NOT A FAIR COMPARISON! 

## were they ever detected at the same camera?
length(unique(dho$cell_id[grepl("KSNP", dho$cell_id)])) # 4 cams 
unique(dho$cell_id[dho$cell_id %in% bp$cell_id]) # both were oonly detected at one camera




```

## Counter-factual results 

```{r Import counter-factual test coefficents}

# First, list all result files
files = list.files(paste(wd, "results/", sep = ""), recursive = T)
# We dont want OE files (that informed GB requirements)
files = files[!grepl("OE", files)]

## specify the MCMC setting were interested in 
# setting = "MIDDLE"
setting = "LONG" # its finally time !

# Subset for the MCMC settings were interested in 
files = files[grepl(setting, files)]
# and the correct time frame
files = files[grepl(time, files)]

# Grab all coefficent dataframe files
files = files[grepl("/counterfactual_coefficent_dataframes/", files)]

## since we have reduced the number of viable species pairs w/ the detection ratio
# thin files to the relevant combos in all_combos

# Extract species pairs from the filenames in `files`
sp_pair = unique(sub(".*coefficents_(SUB-.*DOM-.*)_\\d{8}\\.csv$", "\\1", files))

# Thin the `files` vector by keeping only those that match `all_combos`
files = files[sp_pair %in% all_combos]
rm(sp_pair)


## split apart different tests
f1 = files[grepl("counterfactual1", files)]
f2 = files[grepl("counterfactual2", files)]
f3 = files[grepl("counterfactual3", files)]
f4 = files[grepl("counterfactual4", files)]
f5 = files[grepl("counterfactual5", files)]
f6 = files[grepl("counterfactual6", files)]
# combine into a list
files_list = list("counterfactual1" = f1,
                  "counterfactual2" = f2,
                  "counterfactual3" = f3,
                  "counterfactual4" = f4,
                  "counterfactual5" = f5,
                  "counterfactual6" = f6)
rm(f1,f2,f3,f4,f5,f6, files)

# import them all
res = list()
for(i in 1:length(files_list)){
  
  # select one list of files
  fl = files_list[[i]]
  
  # temp list
  temp = list()
  ## verify we have data first! 
  if(length(fl)>0){
    for(l in 1:length(fl)){
    
    ## grab the matching species pair here
    match = all_combos[sapply(all_combos, grepl, x = fl[l])]
    
    ## but I removed one mod, so bypass this option if there are no matches. 
    if(length(match) == 0){
      next
    } # end no match condition
    
    ## verify there are no repeats here
    res_search = fl[grepl(match, fl)]
    ## if there are indeed repeats 
    if(length(res_search) > 1){
      # Extract the date using a regular expression
      dates = sub(".*_(\\d{8})\\.csv$", "\\1", res_search)
      # Order the filenames based on the extracted dates (from most recent to least recent)
      res_search = res_search[order(dates, decreasing = TRUE)]
      # and take the most recent file
      f = res_search[1]
    }else{
      # but if only one, just overwrite file to be the correct one
      f = fl[l]
    }# end multiple file conditon
    
    # ## verify this is a preferred model
    # if(any(sapply(preform$Species_Pair[preform$preference == "preferred"], 
    #               function(x) grepl(x, f)))){
      
          # import it
    dat = read.csv(paste(wd, "results/", f, sep = ""))
    
    # add the MCMC setting
    dat$MCMC_setting = setting

    # save it
    temp[[l]] = dat
      
    # }else{
    #   ## but if not, skip it! 
    #   next
    # } # end preferred prey prefrerence 
      
  } # end for loop with l
  }else{
    ## but if not, skip it! 
    next
  } # end length condition
  
  ## turn into a DF 
  r = do.call(rbind, temp)
  
  ## Add the testing column
  if(names(files_list)[i] == "counterfactual1"){ r$counter_factual_test = "isolate_extirpations" }
  if(names(files_list)[i] == "counterfactual2"){ r$counter_factual_test = "site_matching_ThaiEFC" }
  if(names(files_list)[i] == "counterfactual3"){ r$counter_factual_test = "isolate_altitude" }
  if(names(files_list)[i] == "counterfactual4"){ r$counter_factual_test = "isolate_FLII" }
  if(names(files_list)[i] == "counterfactual5"){ r$counter_factual_test = "isolate_HFP" }
  if(names(files_list)[i] == "counterfactual6"){ r$counter_factual_test = "remove_community_detections" }
  # if(names(files_list)[i] == "counterfactual7"){ r$counter_factual_test = "new_variable_unmeasured_site_quality" }

  # and save
  res[[i]] = r
  
}
rm(r,i,l,dat,temp,fl,f)

## Convert to a dataframe
coeff_cf = do.call(rbind, res)
rm(res)

## inspect
table(coeff_cf$counter_factual_test)

## make sure col names match other coefficents 
setdiff(names(coeff), names(coeff_cf)) # need to split sub and dom species

## split apart species pair into sub vs dom species
coeff_cf <- within(coeff_cf, {
  sub_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[1])
  dom_sp <- sapply(strsplit(Species_Pair, "~"), function(x) x[2])
})
coeff_cf$dom_sp = gsub("DOM-", "", coeff_cf$dom_sp)
coeff_cf$sub_sp = gsub("SUB-", "", coeff_cf$sub_sp)

## only want the preferred pred-prey pairs 
pref_pairs = preform$Species_Pair[preform$preference == "preferred"]

## grab those pairs from the larger coeff DF 
coeff_pref = coeff[coeff$Species_Pair %in% pref_pairs,]

## add the testing column
coeff_pref$counter_factual_test = "original_test"

## and Rbind them together
coeff_cf = rbind(coeff_cf, coeff_pref)
# clean up
rm(coeff_pref, pref_pairs)

```

```{r Import counter-factual test PPC values}
# First, list all result files
files = list.files(paste(wd, "results/", sep = ""), recursive = T)
# We dont want OE files (that informed GB requirements)
files = files[!grepl("OE", files)]

## specify the MCMC setting were interested in 
# setting = "MIDDLE"
setting = "LONG"

# Subset for the MCMC settings were interested in 
files = files[grepl(setting, files)]

# Grab all coefficent dataframe files
files = files[grepl("/counterfactual_PPC_dataframes/", files)]

## since we have reduced the number of viable species pairs w/ the detection ratio
# thin files to the relevant combos in all_combos

# Extract species pairs from the filenames in `files`
sp_pair = sub(".*BPV_and_Chat_values_(SUB-.*DOM-.*)_\\d{8}\\.csv$", "\\1", files)

# Thin the `files` vector by keeping only those that match `all_combos`
files = files[sp_pair %in% all_combos]
rm(sp_pair)

## split apart different tests
f1 = files[grepl("counterfactual1", files)]
f2 = files[grepl("counterfactual2", files)]
f3 = files[grepl("counterfactual3", files)]
f4 = files[grepl("counterfactual4", files)]
f5 = files[grepl("counterfactual5", files)]
f6 = files[grepl("counterfactual6", files)]
# combine into a list 
files_list = list("counterfactual1" = f1,
                  "counterfactual2" = f2,
                  "counterfactual3" = f3,
                  "counterfactual4" = f4,
                  "counterfactual5" = f5,
                  "counterfactual6" = f6)
rm(f2,f3,f4,f5,f6, files)

# import them all
res = list()
for(i in 1:length(files_list)){
  
  # select one list of files
  fl = files_list[[i]]
  
  # temp list
  temp = list()
  ## verify we have results first!
  if(length(fl)> 0){
     for(l in 1:length(fl)){
    
    ## grab the matching species pair here
    match = all_combos[sapply(all_combos, grepl, x = fl[l])]
    
    ## but I removed one mod, so bypass this option if there are no matches. 
    if(length(match) == 0){
      next
    } # end no match condition
    
    ## verify there are no repeats here
    res_search = fl[grepl(match, fl)]
    ## if there are indeed repeats 
    if(length(res_search) > 1){
      # Extract the date using a regular expression
      dates = sub(".*_(\\d{8})\\.csv$", "\\1", res_search)
      # Order the filenames based on the extracted dates (from most recent to least recent)
      res_search = res_search[order(dates, decreasing = TRUE)]
      # and take the most recent file
      f = res_search[1]
    }else{
      # but if only one, just overwrite file to be the correct one
      f = fl[l]
    }# end multiple file conditon
    
    # ## verify this is a preferred model
    # if(any(sapply(preform$Species_Pair[preform$preference == "preferred"], 
    #               function(x) grepl(x, f)))){
      
      # import it
      dat = read.csv(paste(wd, "results/", f, sep = ""))
      
      # add the MCMC setting
      dat$MCMC_setting = setting
      
      # save it
      temp[[l]] = dat
      
    # }else{
    #   ## but if not, skip it! 
    #   next
    # } # end preferred prey prefrerence 
    
     } # end loop per l
  }else{
    # but if not, skip to the next! 
    next
  } # end length condition
  
  ## turn into a DF 
  r = do.call(rbind, temp)
  
  ## Add the testing column
  if(names(files_list)[i] == "counterfactual1"){ r$counter_factual_test = "isolate_extirpations" }
  if(names(files_list)[i] == "counterfactual2"){ r$counter_factual_test = "site_matching_ThaiEFC" }
  if(names(files_list)[i] == "counterfactual3"){ r$counter_factual_test = "isolate_altitude" }
  if(names(files_list)[i] == "counterfactual4"){ r$counter_factual_test = "isolate_FLII" }
  if(names(files_list)[i] == "counterfactual5"){ r$counter_factual_test = "isolate_HFP" }
  if(names(files_list)[i] == "counterfactual6"){ r$counter_factual_test = "remove_community_detections" }
  # if(names(files_list)[i] == "counterfactual7"){ r$counter_factual_test = "new_variable_unmeasured_site_quality" }
  
  
  # and save
  res[[i]] = r
  
}
rm(r,i,l,dat,temp,fl,f, files_list)

## Convert to a dataframe
ppc_values_cf = do.call(rbind, res)
rm(res)
ppc_values_cf$X = NULL # damn rownames

### Now pull out the matching values from original tests
ppc_pref = preform[preform$preference == "preferred",]
# check if cols match 
setdiff(names(ppc_values_cf), names(preform)) # need to add test name
# add the test 
ppc_pref$counter_factual_test = "original_test"
# and select the relevant matching cols 
ppc_pref = ppc_pref[, names(ppc_values_cf)]
# And finally rbind the rest! 
ppc_values_cf = rbind(ppc_pref, ppc_values_cf)
rm(ppc_pref)

```

```{r Import counter-factual data}
## The idea is to track which models are completed vs not
cf_data_files = list.files(paste(wd, "data/step2_output_CoA_bundles/counterfactual_testing/", sep = ""), recursive = T)
## remove old files
cf_data_files = cf_data_files[! grepl("OLD/", cf_data_files)]

## import and save in a dataframe of results
cf_mods = data.frame(matrix(NA, ncol = 2))
names(cf_mods) = c("counter_factual_test", "Species_Pair")
for(i in 1:length(cf_data_files)){
  # grab empty df
  df = cf_mods[0,]
  # make a path
  path = paste(wd, "data/step2_output_CoA_bundles/counterfactual_testing/", cf_data_files[i], sep = "")
  # import
  dat = readRDS(path)
  # grab the names
  sp = names(dat)
  # add to df
  df[1:length(sp), "Species_Pair"] = sp
  # re-name to match format
  if(grepl("counterfactual1", cf_data_files[i])){ df$counter_factual_test = "isolate_extirpations" }
  if(grepl("counterfactual2", cf_data_files[i])){ df$counter_factual_test = "site_matching_ThaiEFC" }
  if(grepl("counterfactual3", cf_data_files[i])){ df$counter_factual_test = "isolate_altitude" }
  if(grepl("counterfactual4", cf_data_files[i])){ df$counter_factual_test = "isolate_FLII" }
  if(grepl("counterfactual5", cf_data_files[i])){ df$counter_factual_test = "isolate_HFP" }
  if(grepl("counterfactual6", cf_data_files[i])){ df$counter_factual_test = "remove_community_detections" }
  # and rbind with final res
  cf_mods = rbind(cf_mods, df)
}
rm(i, sp, df, path, dat)

# verify were distinct
cf_mods = distinct(cf_mods)

# and remove any NA 
cf_mods = cf_mods[!is.na(cf_mods$Species_Pair), ]

```

```{r Determine support for counter-factual tests}
# 
# ## Also, make sure ppc_values_cf has community results from the original test
add = ppc_values[ppc_values$Species_Pair %in% preform$Species_Pair[preform$preference == "community" & preform$support == "Supported"], ]
# check what cols are missing
setdiff(names(ppc_values_cf), names(add))
# just add the test! 
add$counter_factual_test = "original_test"
# do the rbind
ppc_values_cf = rbind(ppc_values_cf, add)
rm(add)


#### Bayes p-value
## Add a column denoting if the BPV values converged based on a wide range to account for many mods 
ppc_values_cf$BPV_valid = "No"
ppc_values_cf$BPV_valid[ppc_values_cf$BPV.dom >= 0.15 & ppc_values_cf$BPV.dom <= 0.85 &
                          ppc_values_cf$BPV.sub >= 0.15 & ppc_values_cf$BPV.sub <= 0.85] = "Yes"
table(ppc_values_cf$BPV_valid[!is.na(ppc_values_cf$Interaction_Estimate)]) 
# majority are valid, good! 

#### Over-dispersion
## add a column denoting if over dispersion remains with a wide range to account for many mods 
ppc_values_cf$OD_valid = "No"
ppc_values_cf$OD_valid[ppc_values_cf$Chat.dom >= 0.95 & ppc_values_cf$Chat.dom <= 1.3 &
                         ppc_values_cf$Chat.sub >= 0.95 & ppc_values_cf$Chat.sub <= 1.3] = "Yes"
table(ppc_values_cf$OD_valid[!is.na(ppc_values_cf$Interaction_Estimate)]) 
## vast majority are good! 

#### SIV parameter
## add a column denoting if the species interaction parameter converged 
ppc_values_cf$parameter_valid = "No"
ppc_values_cf$parameter_valid[ppc_values_cf$Rhat >= 0.99 & ppc_values_cf$Rhat <= 1.2] = "Yes"
table(ppc_values_cf$parameter_valid[!is.na(ppc_values_cf$Interaction_Estimate)])
# majority are valid, good!

## split apart species pair into sub vs dom species
ppc_values_cf <- within(ppc_values_cf, {
  sub_species <- sapply(strsplit(Species_Pair, "~"), function(x) x[1])
  dom_species <- sapply(strsplit(Species_Pair, "~"), function(x) x[2])
})
ppc_values_cf$dom_species = gsub("DOM-", "", ppc_values_cf$dom_species)
ppc_values_cf$sub_species = gsub("SUB-", "", ppc_values_cf$sub_species)

## Add the direction of the relationship
ppc_values_cf$direction[ppc_values_cf$sub_species %in% c("Panthera_tigris", "Panthera_pardus", "Neofelis_genus", "Cuon_alpinus")] = "bottom-up"
ppc_values_cf$direction[ppc_values_cf$dom_species %in% c("Panthera_tigris", "Panthera_pardus","Neofelis_genus", "Cuon_alpinus")] = "top-down" # this should allow large carnivore pairings to be top-down

## Assign 3 levels of non-support --> unsupported_1, unsupported_2, unsupported_3
ppc_values_cf$support[ppc_values_cf$BPV_valid == "No" |
                        ppc_values_cf$OD_valid == "No" |
                        ppc_values_cf$parameter_valid == "No"] = "Unsupported_3" # lowest level of support --> bad mod.
ppc_values_cf$support[ppc_values_cf$BPV_valid == "Yes" & 
                        ppc_values_cf$OD_valid == "Yes" &
                        ppc_values_cf$parameter_valid == "Yes" &
                        ppc_values_cf$Significance == "Non-Significant"] = "Unsupported_2" # mid-low support --> good mod, but not important
ppc_values_cf$support[ppc_values_cf$BPV_valid == "Yes" & 
                        ppc_values_cf$OD_valid == "Yes" &
                        ppc_values_cf$parameter_valid == "Yes" &
                        ppc_values_cf$Significance == "Significant" &
                        ppc_values_cf$direction == "top-down" &
                        ppc_values_cf$Interaction_Estimate > 0] = "Unsupported_1" # almost supportive --> good model, significant result, but not in correct direction for hypothesis.  
ppc_values_cf$support[ppc_values_cf$BPV_valid == "Yes" & 
                        ppc_values_cf$OD_valid == "Yes" &
                        ppc_values_cf$parameter_valid == "Yes" &
                        ppc_values_cf$Significance == "Significant" &
                        ppc_values_cf$direction == "bottom-up" &
                        ppc_values_cf$Interaction_Estimate < 0] = "Unsupported_1" # Same as above, but applied for bottom-up direction. 
## assign which models support our hypothesis
ppc_values_cf$support[ppc_values_cf$BPV_valid == "Yes" & 
                        ppc_values_cf$OD_valid == "Yes" &
                        ppc_values_cf$parameter_valid == "Yes" &
                        ppc_values_cf$Significance == "Significant" &
                        ppc_values_cf$direction == "top-down" &
                        ppc_values_cf$Interaction_Estimate <= 0] = "Supported" # good model, significant result, in correct direction for hypothesis.  
ppc_values_cf$support[ppc_values_cf$BPV_valid == "Yes" & 
                        ppc_values_cf$OD_valid == "Yes" &
                        ppc_values_cf$parameter_valid == "Yes" &
                        ppc_values_cf$Significance == "Significant" &
                        ppc_values_cf$direction == "bottom-up" &
                        ppc_values_cf$Interaction_Estimate >= 0] = "Supported" # Same as above, but applied for bottom-up direction. 
## inspect
table(ppc_values_cf$support);anyNA(ppc_values_cf$support) # must be F for NA! 

## Since I have now added a handful of community models to the mix, make sure to assign preferred vs community mods. 
pref_mods = preform$Species_Pair[preform$preference == "preferred"]
ppc_values_cf$preference[ppc_values_cf$Species_Pair %in% pref_mods] = "preferred"
ppc_values_cf$preference[! ppc_values_cf$Species_Pair %in% pref_mods] = "community"
table(ppc_values_cf$preference)


```

```{r Determine agreement across counter-factual tests}

## Which species pairs have similar results across tests?
ppc_values_cf$testing_agreement = NA
for(i in 1:length(unique(ppc_values_cf$Species_Pair))){
  
  ## select data from one pair
  dat = ppc_values_cf[ppc_values_cf$Species_Pair == unique(ppc_values_cf$Species_Pair)[i], ]
  ## for the sake of testing a new CF, remove CF7
  # dat = dat[dat$counter_factual_test != "new_variable_unmeasured_site_quality",] # come here and change if we want to keep this! 

  ## if all support values are the same 
  if(length(unique(dat$support)) == 1 & 
     length(unique(dat$counter_factual_test)) > 1){
    
    ## and if all of those support values are supported
    if(unique(dat$support) == "Supported"){
      ## update w/ good news
      ppc_values_cf$testing_agreement[ppc_values_cf$Species_Pair == unique(ppc_values_cf$Species_Pair)[i]] = "agreement"
    }else{
      ## update w/ bad news
      ppc_values_cf$testing_agreement[ppc_values_cf$Species_Pair == unique(ppc_values_cf$Species_Pair)[i]] = "disagreement"
    } # end supported condition
  }else{
    ## update w/ bad news
    ppc_values_cf$testing_agreement[ppc_values_cf$Species_Pair == unique(ppc_values_cf$Species_Pair)[i]] = "disagreement"
  } # end length condition
}# end per sp 
rm(i, dat)

## inspect
anyNA(ppc_values_cf$testing_agreement) # MUST BE F
table(ppc_values_cf$testing_agreement) # There is agreement! 

# Grab all mods that agree across methods, per direction, per preference
a = sort(unique(ppc_values_cf$Species_Pair[ppc_values_cf$testing_agreement == "agreement" & ppc_values_cf$direction == "top-down" & ppc_values_cf$preference == "preferred"]))
b = sort(unique(ppc_values_cf$Species_Pair[ppc_values_cf$testing_agreement == "agreement" & ppc_values_cf$direction == "bottom-up" & ppc_values_cf$preference == "preferred"]))
## organize w/ top-down first, followed by bottom-up
agree_pref = c(a,b)

## do the same for the community
a = sort(unique(ppc_values_cf$Species_Pair[ppc_values_cf$testing_agreement == "agreement" & ppc_values_cf$direction == "top-down" & ppc_values_cf$preference == "community"]))
b = sort(unique(ppc_values_cf$Species_Pair[ppc_values_cf$testing_agreement == "agreement" & ppc_values_cf$direction == "bottom-up" & ppc_values_cf$preference == "community"]))
## organize w/ top-down first, followed by bottom-up
agree_comm = c(a,b)
rm(a,b)




```

We implemented a total of `r length(unique(ppc_values_cf$counter_factual_test)) - 1` counter-factual tests that will be compared with the original tests for a total of `r length(unique(ppc_values_cf$counter_factual_test))` tests. The key inference here will be determining which species pairs agree across all possible tests, noting that not every species pairing was able to be tested in every way. Currently, all tests have been run with the **MCMC setting `r paste(setting)`**. It is also important to note that while we ran counter factual tests for all `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$preference == "preferred"]))` preferred models, **we also ran counter factual tests for an additional `r length(unique(preform$Species_Pair[preform$preference == "community" & preform$support == "Supported"]))` community models that gereated supported results in the original test**. 

* The first test, **`r paste(unique(ppc_values_cf$counter_factual_test)[1])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[1] & ppc_values_cf$preference == "community"])` supported community models**.

* The second test, **`r paste(unique(ppc_values_cf$counter_factual_test)[2])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[2] & ppc_values_cf$preference == "community"])` supported community models**.

* The third test, **`r paste(unique(ppc_values_cf$counter_factual_test)[3])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[3] & ppc_values_cf$preference == "community"])` supported community models**.

* The fourth test, **`r paste(unique(ppc_values_cf$counter_factual_test)[4])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[4] & ppc_values_cf$preference == "community"])` supported community models**.

* The fifth test, **`r paste(unique(ppc_values_cf$counter_factual_test)[5])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[5] & ppc_values_cf$preference == "community"])` supported community models**.

* The sixth test, **`r paste(unique(ppc_values_cf$counter_factual_test)[6])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[6] & ppc_values_cf$preference == "community"])` supported community models**.

* The seventh test, **`r paste(unique(ppc_values_cf$counter_factual_test)[7])`**, included a total of `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "preferred"]))` preferred models and `r length(unique(ppc_values_cf$Species_Pair[ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "community"]))` community models. 
Based on the same criteria above for the original tests, the preferred models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "preferred"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "preferred"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "preferred"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "preferred"])` supported preferred models**.
Based on the same criteria above for the original tests, the community models contained `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_3" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "community"])` unsupported_3 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_2" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "community"])` unsupported_2 models, `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Unsupported_1" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "community"])` unsupported_1 models, **and `r length(ppc_values_cf$Species_Pair[ppc_values_cf$support == "Supported" & ppc_values_cf$counter_factual_test == unique(ppc_values_cf$counter_factual_test)[7] & ppc_values_cf$preference == "community"])` supported community models**.

Finally, we assessed which species pairs agreed across the different tests and this resulted in `r length(preform$Species_Pair[preform$Species_Pair %in% agree_pref & preform$direction == "top-down"])` preferred top-down model and `r length(preform$Species_Pair[preform$Species_Pair %in% agree_pref & preform$direction == "bottom-up"])` community bottom-up models. This also resulted in `r length(preform$Species_Pair[preform$Species_Pair %in% agree_comm & preform$direction == "top-down"])` community top-down model and `r length(preform$Species_Pair[preform$Species_Pair %in% agree_comm & preform$direction == "bottom-up"])` community bottom-up models. 

* **The `r length(agree_pref)` preferred species pairs that agree across different counter-factual tests are: `r paste(agree_pref, collapse = ", ")`**. 

* **The `r length(agree_comm)` community species pairs that agree across different counter-factual tests are: `r paste(agree_comm, collapse = ", ")`**.

```{r Inspect new counterfactual test 7, eval=FALSE}
### OLD CODE, leaving for now, but will not assess when knitting. 
### Also, I have deleted the old Markdown text for this document to ensure a clean knit
### but I have saved the html output in the OLD folder for back up. 

## grab original + CF7 to compare
new_dat = ppc_values_cf[ppc_values_cf$counter_factual_test == "new_variable_unmeasured_site_quality",]
dat = ppc_values_cf[ppc_values_cf$counter_factual_test == "original_test",]
# thin dat to match limited results (still running on HPC!)
dat = dat[dat$Species_Pair %in% new_dat$Species_Pair, ]

### Predictions: 
## 1) Ultimately, the results from this test will be more conservative than the original test if the new variable is capturing unmeasured variation. 
## 2) Large positive (1 or greater) unsupported top-down in the original test will now produce either small and unsupported if not an important interaction or a negative interaction if real.
## 3) Small positive supported bottom-up in the original test should now produce either no change and remain significant if a legitimate interaction, or become unsupported if unmeasured variation was driving a spurious positive correlation. 

#
##
### prediction 1, check supported results between tests 
length(new_dat$Species_Pair[new_dat$support == "Supported"]) # new variable has 8 
length(dat$Species_Pair[dat$support == "Supported"]) # old test has 11. 

## does old test contain any significnat mods not present in new test?
setdiff(dat$Species_Pair[dat$support == "Supported"], 
        new_dat$Species_Pair[new_dat$support == "Supported"]) # yes, three extra mods that were not supported in new test, but otherwise in full agreement. 
sort(dat$Species_Pair[dat$support == "Supported"])
sort(new_dat$Species_Pair[new_dat$support == "Supported"]) # can confirm! But CF7 is still running for tiger -> muntjac mod :(

## This suggests the positive bottom-up relationship for these three: "SUB-Cuon_alpinus~DOM-Muntiacus_genus", "SUB-Cuon_alpinus~DOM-Sus_scrofa", "SUB-Neofelis_genus~DOM-Macaca_nemestrina" was due to unmeasured variaion. 

#
##
### Prediction 2, inspect top-down results 

## grab large positive unsupported top-down results
check_old = dat[dat$Interaction_Estimate >= 1 & grepl("Unsupport", dat$support), ]
## and grab the matching pairs from new test
check_new = new_dat[new_dat$Species_Pair %in% check_old$Species_Pair, ]
# combine
check = rbind(check_old, check_new)
unique(check$support) # all unsup 3 --> poor fits 

## change the name so its a bit nicer on the plot
check$counter_factual_test[check$counter_factual_test == "new_variable_unmeasured_site_quality"] = "new_test"

## visualize results 
check_td_plot = 
ggplot(check, aes(x = Interaction_Estimate, fill = counter_factual_test))+
    geom_histogram(aes(y=after_stat(count)), colour="black", binwidth = .1, alpha = 1)+
    theme_classic()+
    geom_vline(aes(xintercept = 0), linetype = "dashed", color = "firebrick4", alpha = .5)+
    labs(x = "Species Interaction Value",  y = "Number of pairwise co-abundance models", color = NULL)+
    theme(axis.text.x = element_text(size = 16),
          axis.text.y = element_text(size = 16),
          axis.text = element_text(color = "black"),
          text = element_text(family = "Helvetica"))
## inspect summary of values
summary(check_old$Interaction_Estimate) # median is 1.1, mean is 1.3, min = 1.1
summary(check_new$Interaction_Estimate) # median is 1.07, mean is 0.9, max = 1.1
## seems like it worked as predicted! 

#
##
### Prediciton 3, inspect bottom-up results 

## who was supported bottom-up in original test?
check2_old = dat[dat$support == "Supported" & dat$direction == "bottom-up",]
## and grab the same from new test 
check2_new = new_dat[new_dat$Species_Pair %in% check2_old$Species_Pair, ]

## which species pairs are no longer supported
setdiff(check2_old$Species_Pair, check2_new$Species_Pair[check2_new$support == "Supported"]) # same three as above. 
# combine
check_bu = rbind(check2_old, check2_new)
table(check_bu$support) # all supported except for the three no longer in new test. 

## change the name so its a bit nicer on the plot
check_bu$counter_factual_test[check_bu$counter_factual_test == "new_variable_unmeasured_site_quality"] = "new_test"


## visualize results 
check_bu_plot = 
ggplot(check_bu, aes(x = Interaction_Estimate, fill = counter_factual_test))+
    geom_histogram(aes(y=after_stat(count)), colour="black", binwidth = .1, alpha = 1)+
    theme_classic()+
    geom_vline(aes(xintercept = 0), linetype = "dashed", color = "firebrick4", alpha = .5)+
    labs(x = "Species Interaction Value", y = "Number of pairwise co-abundance models", color = NULL)+
    theme(axis.text.x = element_text(size = 16),
          axis.text.y = element_text(size = 16),
          axis.text = element_text(color = "black"),
          text = element_text(family = "Helvetica"))
## inspect summary of values
summary(check2_old$Interaction_Estimate) 
# median is 0.13, mean is 0.22, min = 0.06, max = 0.57
summary(check2_new$Interaction_Estimate[check2_new$support == "Supported"]) 
# median is 0.12, mean is 0.24, min = 0.1,  max = 0.54
## seems like it worked as predicted --> more conservative! 

```

## Save results

Save these results to dropbox, in this file directory: Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/data/step3_output_combined_results. It is important to note that Tables S3 (full model performance and SIVs) and S4 (supported counterfactual results) are generated from this script, so make sure to include these in the manuscript! 

```{r Save relevant dataframes}

## first, set the working directory where we will save these files
wd = "/Users/zachary_amir/Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/data/step3_output_combined_results"

## and grab the date! 
day<-str_sub(Sys.Date(),-2)
month<-str_sub(Sys.Date(),-5,-4)
year<-str_sub(Sys.Date(),-10,-7)
date = paste(year,month,day, sep = "")
rm(year,month,day)


### Coefficients data frame

# make a saving path 
path = paste(wd, "/compiled_co-abundance_coefficients_dataframe_", length(unique(coeff$Species_Pair)), "_completed_models_", date, ".csv", sep = "")
# and save it! 
write.csv(coeff, path)

### PPC 

# make a saving path 
path = paste(wd, "/compiled_co-abundance_PPC_values_dataframe_", length(unique(coeff$Species_Pair)), "_completed_models_", date, ".csv", sep = "")
# and save it! 
write.csv(ppc_values, path)

### Preform

# make a saving path 
path = paste(wd, "/compiled_co-abundance_preformance_and_support_dataframe_", length(unique(preform$Species_Pair[!is.na(preform$Interaction_Estimate)])), "_completed_models_", date, ".csv", sep = "")
# and save it! 
write.csv(preform, path)

### Make a reduced column version of perform for the supplementary materials 
preform_sub = select(preform, Species_Pair,	dom_species,	sub_species,	SUB_guild,	DOM_guild,	guild_pair,	Interaction_Estimate,	SD,	lower,	upper,	Rhat,	Significance,	BPV.dom,	BPV.sub,	Chat.dom,	Chat.sub,	BPV_valid,	OD_valid,	parameter_valid,	direction,	preference,	support)

# make a path 
path = paste(wd, "/model_performance_and_SIVs_", nrow(preform_sub), "_completed_models_", date, ".csv", sep = "")
# save it
write.csv(preform_sub, path, row.names = F)

### CF coefficients

# make a saving path 
path = paste(wd, "/compiled_co-abundance_counter-factual_tests_coefficients_dataframe_", length(unique(coeff_cf$Species_Pair)), "_completed_models_", date, ".csv", sep = "")
# and save it! 
write.csv(coeff_cf, path)

### CF PPC

# make a saving path 
path = paste(wd, "/compiled_co-abundance_counter-factual_tests_PPC_preformance_and_support_dataframe_", length(unique(coeff_cf$Species_Pair)), "_completed_models_", date, ".csv", sep = "")
# and save it! 
write.csv(ppc_values_cf, path)

### key mods for all CF tests

# make a saving path 
path = paste(wd, "/co-abundance_counter-factual_tests_PPC_preformance_and_support_for_", length(agree_pref), "_supported_preferred_models_and_", length(agree_comm), "_supported_community_models_across_all_tests_", date, ".csv", sep = "")
# re-order cols and organize, since this will be a supplemental table 
key_mods = ppc_values_cf[ppc_values_cf$Species_Pair %in% c(agree_pref, agree_comm), ]
key_mods = select(key_mods, Species_Pair, dom_species, sub_species, direction, preference,  counter_factual_test, Interaction_Estimate, SD, lower, upper, Significance, Rhat, parameter_valid, BPV.dom, BPV.sub, BPV_valid, Chat.dom, Chat.sub, OD_valid, support)

# Ensure "preferred" is sorted before "community" and top-down is sorted before bottom-up, then by species_pair
key_mods_sorted <- key_mods %>%
  arrange(factor(preference, levels = c("preferred", "community")), 
          factor(direction, levels = c("top-down", "bottom-up")),
          Species_Pair)
# and save it! 
write.csv(key_mods_sorted, path, row.names = F)


### Also, good idea to save the 11 species we will need good prediciton graphs of later
save = bdata[names(bdata)%in% c(agree_pref, agree_comm)]
# make a path
path = paste(wd, "/Bundled_data_for_co-abundance_predictions_", length(c(agree_pref, agree_comm)), "_key_species_pairs_",date, ".RDS", sep = "")
# and save it! 
saveRDS(save, path)

```

```{r Also save supported community results for further counter-factual testing, eval=FALSE}
# We assume that the community models are least-likely to be interacting IRL
# but we can test this by putting them against the counter factual tests

## if a community-level result passes all tests, then maybe thats a species interaction
## that deserves much more attention than is currently being given! 

## grab which community species pairs were supported
comm_sp = preform$Species_Pair[preform$support == "Supported" & 
                                 preform$preference == "community"]
length(comm_sp)
31* 6  # will be an additional 186 models on the HPC. 
# probably takes 2-3 weeks to complete, but this is for curiosity (mainly, pending results)

## save this vector as an RDS object, which will then be loaded in to step 2
saveRDS(comm_sp, paste(wd, "/supported_community_", length(comm_sp),
                       "_species_pairs_vector_for_counterfactual_testing_", 
                       date, ".csv", sep = ""))

```
