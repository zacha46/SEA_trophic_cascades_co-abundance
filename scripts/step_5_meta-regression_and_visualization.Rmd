---
title: "step 5 meta-regression and visualization"
author: "Zachary Amir"
date: "`r Sys.time()`"
output: html_document
---

```{r global-options, include=FALSE, warning=FALSE, error=FALSE}
## We can knit this into a nice document! but dont include all the code unless otherwise specified (i.e. include=TRUE)
knitr::opts_chunk$set(include=FALSE, warning=FALSE, error = FALSE)

## start fresh
rm(list = ls())

## load libraries
library(tidyverse)        ## For basic data wrangling
# library(plyr)             ## For ddply
library(lmerTest)         ## For meta-regressions (w/ p-values) of model coefficents

```

## Introduction

This RMarkdown file will be used to implement a meta-regression on the coefficients of preferred predator-prey co-abundance models. The goal of this exercise is to examine the effect of observed variables mediating predator-prey relationships and deepen our understanding of possible unmeasured variables mediating observed relationships. 

```{r Import model coefficents and preformance data}
## Remember, this data was collated in step3!

## Set the working directory where the data lives
wd = "/Users/zachary_amir/Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/data/step3_output_combined_results/"

## list all relevant files
files = list.files(wd)

## dont want counter-factual results (yet)
files = files[! grepl("counter-factual", files)]

### Import coefficients
c_file = files[grepl("coefficients", files)]
coeff = read.csv(paste(wd, c_file, sep = ""))
coeff$X = NULL # damn row names!

### Import preformance results
p_file = files[grepl("preform", files)]
preform = read.csv(paste(wd, p_file, sep = ""))
preform$X = NULL # damn row names! 

## keep enviro clean
rm(p_file, files, c_file)
```

```{r Prepare data for meta-regression}

## We are only interested in preferred models, so grab these pairs
pairs = unique(preform$Species_Pair[preform$preference == "preferred"])

## thin coeff and preform to match 
coeff = coeff[coeff$Species_Pair %in% pairs,]
preform = preform[preform$Species_Pair %in% pairs, ]

## Inspect coeff
str(coeff)

## need relevant information from preform
str(preform)
add = select(preform, Species_Pair, direction, preference, guild_pair, support_conserv, support )

## merge them together
setdiff(coeff$Species_Pair, add$Species_Pair)
setdiff(add$Species_Pair, coeff$Species_Pair) # no diff, safe to merge
## if preform has extra values (b/c uncompleted mods)
if(length(setdiff(add$Species_Pair, coeff$Species_Pair))>0){
  # thin add to what is completed
  add = add[add$Species_Pair %in% coeff$Species_Pair, ]
}
coeff = merge(coeff, add, by = "Species_Pair")
rm(add)

## should have a total of 66 preferred mods 
table(coeff$preference[coeff$var == "Species_Interaction"]) 
table(preform$preference) # these should be the same, but two mods still running

## Create a new column for simple support into three levels: top-down, bottom-up, and unsupported
coeff$support_simple = coeff$direction
coeff$support_simple[grepl("Unsupported", coeff$support)] = "unsupported"
table(coeff$support_simple[coeff$var == "Species_Interaction"]) # looks good! 

## grab the key variables we are interested in 
vars = c("HFP","FLII","Elevation","Community_detections","Species_Interaction","Active_cams") # will remove effort later


```

Before we begin the meta-regressions, it will be important to examine the summary statistics of the posterior effect sizes from our key variables: `r paste(vars, collapse = " & ")` from all `r length(pairs)` preferred predator-prey co-abundance models. 

* For `r vars[1]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[1]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[1]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[1]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[1]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[1]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[1] & coeff$support_simple == "unsupported"]), 2)`

* For `r vars[2]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[2]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[2]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[2]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[2]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[2]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[2] & coeff$support_simple == "unsupported"]), 2)`

* For `r vars[3]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[3]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[3]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[3]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[3]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[3]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[3] & coeff$support_simple == "unsupported"]), 2)`

* For `r vars[4]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[4]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[4]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[4]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[4]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[4]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[4] & coeff$support_simple == "unsupported"]), 2)`

* For `r vars[5]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[5]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[5]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[5]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[5]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[5]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[5] & coeff$support_simple == "unsupported"]), 2)`

* For `r vars[6]`, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[6]]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[6]]), 2)`, and the values range from `r round(min(coeff$mean[coeff$var == vars[6]]), 2)` to `r round(max(coeff$mean[coeff$var == vars[6]]), 2)` with a variance of `r round(var(coeff$mean[coeff$var == vars[6]]), 2)`. 
    * For supported top-down models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "top-down"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "top-down"]), 2)`
    * For supported bottom-up models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "bottom-up"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "bottom-up"]), 2)`
    * For unsupported models, the mean effect size is `r round(mean(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "unsupported"]), 2)` with a standard deviation of `r round(sd(coeff$mean[coeff$var == vars[6] & coeff$support_simple == "unsupported"]), 2)`

## Regressions

```{r implement regressions}

## update vars to NOT include effort
vars = vars[!grepl("cams", vars)]

### first grab the relevant subset of data 
dat = coeff[coeff$preference == "preferred"  & ## only preferred models 
              grepl("SUB", coeff$species) &    ## only interested in effect in subordinate species 
              coeff$var %in% vars, ]

## Create a new column to denote if the subordinate species is a predator or prey 
dat$pred_prey = "prey" # assume prey 
dat$pred_prey[dat$sub_sp %in% c("Panthera_pardus","Panthera_tigris",
                                "Cuon_alpinus", "Neofelis_genus")] = "predator"


### UNDECIDED ABOUT OMITTING OR INCLUDING SOME VS ALL UNSUPPORTED RESULTS
## Currently including all results rather than omitting a subset. 
# but leaving old code that removes it, and text for final html, hashed out here. 
{
  # ### How about we fully omit unsupported_3 b/c its a bad model w/ no inferences
  # ## and combine unsupported_2 and 1 to reduce lines on the graph
  # # but first grab how many rows this is! 
  # rm_dat = dat[grepl("Unsupported_3", dat$support), ]
  # dat = dat[! grepl("Unsupported_3", dat$support), ]
  # These regressions include the posterior effect size from the coefficients described above for all `r nrow(preform)` preferred predator-prey co-abundance models. However, we removed all 'unsupported_3' results, which are models that had unsuitable parameter convergence, Bayes p-values, and/or remaining over-dispersion. This includes `r nrow(rm_dat)` effect sizes, with `r nrow(rm_dat[rm_dat$var == vars[1],])` values from `r vars[1]`, `r nrow(rm_dat[rm_dat$var == vars[2],])` values from `r vars[2]`, `r nrow(rm_dat[rm_dat$var == vars[3],])` values from `r vars[3]`, and finally `r nrow(rm_dat[rm_dat$var == vars[4],])` values from `r vars[4]`.  
}


# create a new column that incorporates predator vs prey and top-down vs bottom up 
dat$support_pred_prey[dat$support == "Supported" & dat$direction == "top-down"] = "supported_top-down"      # this is auto prey
dat$support_pred_prey[dat$support == "Supported" & dat$direction == "bottom-up"] = "supported_bottom-up"    # this is auto predators
dat$support_pred_prey[grepl("Unsupport", dat$support) & dat$direction == "top-down"] = "unsupported_top-down"   # this is auto prey
dat$support_pred_prey[grepl("Unsupport", dat$support) & dat$direction == "bottom-up"] = "unsupported_bottom-up" # this is auto predators
table(dat$support_pred_prey) # divide each by 4 for total number of mods (b/c 4 covs per mod)


### Will run regressions where the effect size is the response variable
## and the different covariates are the factorial predictors. 
# looped through each subset of data based on support_pred_prey

## loop through so we dont have to code them all out 
support_pred_prey = unique(dat$support_pred_prey)
# store results here
res = list()
# loopin' 
for(i in 1:length(support_pred_prey)){
 
  # select a pred or prey
  p = support_pred_prey[i]
    
    ## make the mod w/ the RE 
  m = lmerTest::lmer(mean ~ var-1 + (1 | sub_sp), weights = 1/sd, #REML = FALSE, 
                     data = dat[dat$support_pred_prey == p, ])
  
  ## extract values
  m1 = as.data.frame(summary(m)$coefficients)
  
  ## clean up the df
  m1$var = rownames(m1)
  m1$var = gsub("var", "", m1$var)
  names(m1) = c("estimate", "SE", "df", "t value", "p value", "var")
  rownames(m1) = NULL
  
  ## let us know if the model converged or not.
  if(is.null(m@optinfo$conv$lme4$messages)){
    m1$warning = "none"
  }else{
    m1$warning = m@optinfo$conv$lme4$messages
  }

  ## explicitly note which model this was
  m1$support_pred_prey = p

  ## and save it 
  res[[i]] = m1
  
} # end per pred prey 
rm(i,p,m,m1,weights,
   support_pred_prey)
## check results 
es_final = do.call(rbind, res)
str(es_final)
tail(es_final)
summary(es_final)
unique(es_final$support_pred_prey[es_final$warning != "none"]) # When we remove REML in lmerTest, there are no more warnings! 

#need to split support and direction
es_final = separate(es_final, support_pred_prey, c("support", "direction"), sep = "_", remove = F)
str(es_final) # good! 

# inspect
summary(es_final$estimate) # narrow range is good! 
summary(es_final$SE) # even smaller, great. 

## update var to say SIV!
vars[grepl("Species", vars)] = "SIV"
# and make sure we match in ES! 
es_final$var[grepl("Species", es_final$var)] = "SIV"

# rename p value
names(es_final)[grepl("p value", names(es_final))] = "p_value"


```

These regressions are using all posterior effect sizes from the `r nrow(preform)` for the key covariates described above. Only the results from the subordinate species are included in these regressions to ensure a fair comparison with SIV because it is only present in the subordinate species' co-abundance model. The co-abundance model results have been split into four groupings: `r paste(sort(unique(es_final$support_pred_prey)), collapse = ", ")` for a total of four linear (i.e. Gaussian distribution) mixed effect models with a random effect per subordinate species. Each regression's response variable is the posterior effect size, and each effect size is weighted by 1/standard deviation of the posterior effect size. The predictor variable is a categorical variable denoting the variable of interest: `r paste(sort(vars), collapse = ", ")`.

Before we create the graph, we can display the values produced in the regression for each of the variables.

* For `r vars[1]`, the average effect size across the four groupings used in the meta-regression is `r round(mean(es_final$estimate[es_final$var == vars[1]]), 2)` with a standard deviation of `r round(sd(es_final$estimate[es_final$var == vars[1]]), 2)`.
    * For supported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[1] & es_final$support_pred_prey == "supported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[1] & es_final$support_pred_prey == "supported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[1] & es_final$support_pred_prey == "supported_top-down"], 3)`.
    * For unsupported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_top-down"], 3)`.
    * For supported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[1] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[1] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[1] & es_final$support_pred_prey == "supported_bottom-up"], 3)`.
    * For unsupported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[1] & es_final$support_pred_prey == "unsupported_bottom-up"], 3)`.

* For `r vars[2]`, the average effect size from the meta-regression is `r round(mean(es_final$estimate[es_final$var == vars[2]]), 2)` with a standard deviation of `r round(sd(es_final$estimate[es_final$var == vars[2]]), 2)`. 
    * For supported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[2] & es_final$support_pred_prey == "supported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[2] & es_final$support_pred_prey == "supported_top-down"]), 2)`  and a p-value of `r round(es_final$p_value[es_final$var == vars[2] & es_final$support_pred_prey == "supported_top-down"], 3)`.
    * For unsupported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_top-down"], 3)`.
    * For supported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[2] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[2] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[2] & es_final$support_pred_prey == "supported_bottom-up"], 3)`.
    * For unsupported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[2] & es_final$support_pred_prey == "unsupported_bottom-up"], 3)`.

* For `r vars[3]`, the average effect size from the meta-regression is `r round(mean(es_final$estimate[es_final$var == vars[3]]), 2)` with a standard deviation of `r round(sd(es_final$estimate[es_final$var == vars[3]]), 2)`. 
    * For supported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[3] & es_final$support_pred_prey == "supported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[3] & es_final$support_pred_prey == "supported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[3] & es_final$support_pred_prey == "supported_top-down"], 3)`.
    * For unsupported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_top-down"], 3)`.
    * For supported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[3] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[3] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[3] & es_final$support_pred_prey == "supported_bottom-up"], 3)`.
    * For unsupported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[3] & es_final$support_pred_prey == "unsupported_bottom-up"], 3)`.

* For `r vars[4]`, the average effect size from the meta-regression is `r round(mean(es_final$estimate[es_final$var == vars[4]]), 2)` with a standard deviation of `r round(sd(es_final$estimate[es_final$var == vars[4]]), 2)`. 
    * For supported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[4] & es_final$support_pred_prey == "supported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[4] & es_final$support_pred_prey == "supported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[4] & es_final$support_pred_prey == "supported_top-down"], 3)`.
    * For unsupported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_top-down"], 3)`.
    * For supported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[4] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[4] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[4] & es_final$support_pred_prey == "supported_bottom-up"], 3)`.
    * For unsupported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[4] & es_final$support_pred_prey == "unsupported_bottom-up"], 3)`.


* For `r vars[5]`, the average effect size across the four groupings used in the meta-regression is `r round(mean(es_final$estimate[es_final$var == vars[5]]), 2)` with a standard deviation of `r round(sd(es_final$estimate[es_final$var == vars[5]]), 2)`.
    * For supported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[5] & es_final$support_pred_prey == "supported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[5] & es_final$support_pred_prey == "supported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[5] & es_final$support_pred_prey == "supported_top-down"], 3)`.
    * For unsupported top-down models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_top-down"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_top-down"], 3)`.
    * For supported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[5] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[5] & es_final$support_pred_prey == "supported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[5] & es_final$support_pred_prey == "supported_bottom-up"], 3)`.
    * For unsupported bottom-up models, the overall effect size is `r round((es_final$estimate[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` with a standard error of `r round((es_final$SE[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_bottom-up"]), 2)` and a p-value of `r round(es_final$p_value[es_final$var == vars[5] & es_final$support_pred_prey == "unsupported_bottom-up"], 3)`.
```{r Make the OG forest plot }
## prep the data for plotting 

## make an upper and lower CI
es_final$upper = es_final$estimate + es_final$SE
es_final$lower = es_final$estimate - es_final$SE

## rename vars so they are just letters ordered for the graph
es_final$var_letter[es_final$var == "HFP"] = "A)"
es_final$var_letter[es_final$var == "FLII"] = "B)"
es_final$var_letter[es_final$var == "Elevation"] = "C)"
es_final$var_letter[es_final$var == "Community_detections"] = "D)"
es_final$var_letter[es_final$var == "SIV"] = "E)"

## set the factor order, putting SIV at the bottom
es_final$var_letter = factor(es_final$var_letter, levels = c("E)","D)","C)","B)","A)"))

## set the factor order of points on the graph 
es_final$support_pred_prey = factor(es_final$support_pred_prey, levels = c("unsupported_top-down", "supported_top-down","unsupported_bottom-up", "supported_bottom-up"))

## ADDING * to graph is tricky!! hashed out for now in favor of doing it in ppt. 
# ## finally, distinguish if effects are significant
# es_final$sig[es_final$var != "D) Species interaction"] = ifelse(es_final$`p value`[es_final$var != "D) Species interaction"] < 0.05, "*", "")
# table(es_final$sig) # should see 2 stars on the graph
# es_final[es_final$sig == "*",] #usup_TD FLII & unsup_BU elevation --> no sig differences in HFP 
## make the plot! 
forest_plot =
  ggplot(es_final, aes(x = var_letter, y = estimate, ymin=lower, ymax=upper))+
  geom_pointrange(aes(color = support_pred_prey, shape = direction), size = 2, lwd = 2, position= position_dodge(width=.7))+
  # geom_text(aes(y = estimate+.3*sign(estimate), label = sig), position = position_dodge(width = .7), size = 8) + # manually add via ppt to be more clear
  scale_color_manual(values = c( "supported_bottom-up" = "springgreen4",
                                 "unsupported_bottom-up" = "gray32",
                                 "supported_top-down" = "darkorange4",
                                 "unsupported_top-down" = "gray32"))+
  scale_shape_manual(values = c("bottom-up" = 15, "top-down" = 18))+
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.6)+
  coord_flip() +  # flip coordinates (puts labels on y axis)
  labs(y = "Weighted effect size", x = NULL)+ 
  theme_bw()+
  theme(axis.text.x = element_text(size = 22), # change these to 28 if going with model size 
        axis.text.y = element_text(size = 22),
        axis.title.x = element_text(size = 22),
        axis.text = element_text(color = "black"),
        legend.title = element_text(size = 22, family = "Helvetica"),
        legend.text = element_text(size = 22, family = "Helvetica"),
        text = element_text(family = "Helvetica"))

### Create a nicer label for the plot 

## convert to char for easier manipulation
es_final$support_pred_prey = as.character(es_final$support_pred_prey)
# replace undescore with ampersand 
es_final$support_pred_prey = gsub("_", " & ", es_final$support_pred_prey)
table(es_final$support_pred_prey)

### CHANGE THE LABEL TO THIS!! to be more informative
# pt1
es_final$support_pred_prey[es_final$support_pred_prey == "supported & bottom-up"] = paste(length(unique(preform$sub_species[preform$direction == "bottom-up"])), "predator species from", length(unique(preform$Species_Pair[preform$direction == "bottom-up" & preform$support == "Supported"])), "supported bottom-up models")
# pt2
es_final$support_pred_prey[es_final$support_pred_prey == "unsupported & bottom-up"] = paste(length(unique(preform$sub_species[preform$direction == "bottom-up"])), "predator species from", length(unique(preform$Species_Pair[preform$direction == "bottom-up" & grepl("Unsupp", preform$support)])), "unsupported bottom-up models")
# pt3
es_final$support_pred_prey[es_final$support_pred_prey == "unsupported & top-down"] = paste(length(unique(preform$sub_species[preform$direction == "top-down"])), "prey species from", length(unique(preform$Species_Pair[preform$direction == "top-down" & grepl("Unsupp", preform$support)])), "unsupported top-down models")
# pt4
es_final$support_pred_prey[es_final$support_pred_prey == "supported & top-down"] = paste(length(unique(preform$sub_species[preform$direction == "top-down"])), "prey species from", length(unique(preform$Species_Pair[preform$direction == "top-down" & preform$support == "Supported"])), "supported top-down models")
# inspect
table(es_final$support_pred_prey)

### now reverse the factors b/c of coordinate flip 
es_final$support_pred_prey = factor(es_final$support_pred_prey, levels = c("4 predator species from 12 supported bottom-up models", "4 predator species from 20 unsupported bottom-up models","17 prey species from 2 supported top-down models", "17 prey species from 30 unsupported top-down models"))
                                      
## Re-make the ggplot for the label 
label =
ggplot(es_final, aes(x = var, y = estimate, ymin=lower, ymax=upper))+
  geom_pointrange(aes(color = support_pred_prey, shape = direction), size = 2, lwd = 2,
                  position= position_dodge(width=.7))+
  scale_color_manual(values = c( "4 predator species from 12 supported bottom-up models" = "springgreen4",
                                 "4 predator species from 20 unsupported bottom-up models" = "gray32",
                                 "17 prey species from 2 supported top-down models" = "darkorange4",
                                 "17 prey species from 30 unsupported top-down models" = "gray32"))+
  scale_shape_manual(values = c("bottom-up" = 15, "top-down" = 18))+
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.6)+
  coord_flip() +  # flip coordinates (puts labels on y axis)
  labs(y = "Weighted effect size", x = NULL)+#, title = "prey are subordinate in top-down models") +
  theme_bw()+
  theme(axis.text.x = element_text(size = 22), # change these to 28 if going with model size 
        axis.text.y = element_text(size = 22),
        axis.title.x = element_text(size = 22),
        axis.text = element_text(color = "black"),
        legend.title = element_text(size = 22, family = "Helvetica"),
        legend.text = element_text(size = 22, family = "Helvetica"),
        text = element_text(family = "Helvetica"))


```

For each level of support (i.e. `r paste(unique(coeff$support_simple), collapse = ", ")`), documenting sample sizes is important! 

* For supported top-down models, there are `r as.numeric(table(dat$support_pred_prey[dat$var == "Species_Interaction"])[2])` results. 

* For unsupported top-down models, there are `r as.numeric(table(dat$support_pred_prey[dat$var == "Species_Interaction"])[4])` results. 

* For supported bottom-up models, there are `r as.numeric(table(dat$support_pred_prey[dat$var == "Species_Interaction"])[1])` results. 

* For unsupported bottom-up models, there are `r as.numeric(table(dat$support_pred_prey[dat$var == "Species_Interaction"])[3])` results.

For reference, this is what variable each letter represents on the plot:

* The letter `r unique(es_final$var_letter)[1]` corresponds to the variable **`r unique(es_final$var[es_final$var_letter ==  unique(es_final$var_letter)[1]])`**

* The letter `r unique(es_final$var_letter)[2]` corresponds to the variable **`r unique(es_final$var[es_final$var_letter ==  unique(es_final$var_letter)[2]])`**

* The letter `r unique(es_final$var_letter)[3]` corresponds to the variable **`r unique(es_final$var[es_final$var_letter ==  unique(es_final$var_letter)[3]])`**

* The letter `r unique(es_final$var_letter)[4]` corresponds to the variable **`r unique(es_final$var[es_final$var_letter ==  unique(es_final$var_letter)[4]])`**

* The letter `r unique(es_final$var_letter)[5]` corresponds to the variable **`r unique(es_final$var[es_final$var_letter ==  unique(es_final$var_letter)[5]])`**

```{r Visualize the forest plot, include=TRUE, echo=FALSE, fig.width= 12, fig.height=10}
forest_plot
```

```{r Try a new variation of the plot}

# make a new simple col for the label 
es_final$support_pred_prey2 = paste(es_final$support, es_final$direction, sep = "_")
unique(es_final$support_pred_prey2)
# make these super short
es_final$support_pred_prey_letter[es_final$support_pred_prey2 == "unsupported_top-down"] = "4)"
es_final$support_pred_prey_letter[es_final$support_pred_prey2 == "supported_top-down"] = "3)"
es_final$support_pred_prey_letter[es_final$support_pred_prey2 == "unsupported_bottom-up"] = "2)"
es_final$support_pred_prey_letter[es_final$support_pred_prey2 == "supported_bottom-up"] = "1)"
# and assign a factor level
es_final$support_pred_prey_letter = factor(es_final$support_pred_prey_letter, 
                                           levels = c("4)", "3)", "2)", "1)"))
## re-name variables to be fancy 
es_final$var_fancy = es_final$var # this captures elevation
es_final$var_fancy[es_final$var == "FLII"] = "Forest Landscape Integrity Index"
es_final$var_fancy[es_final$var == "HFP"] = "Human Footprint Index"
es_final$var_fancy[es_final$var == "Community_detections"] = "Total wildlife capture rate"
es_final$var_fancy[es_final$var == "SIV"] = "Species Interaction Value"

# finally, assign facet wrap to variable for clear order
es_final$var_fancy = factor(es_final$var_fancy, levels = c("Elevation","Forest Landscape Integrity Index","Human Footprint Index", "Total wildlife capture rate","Species Interaction Value"))

## and try a facet wrap 
facet_var = 
ggplot(es_final, aes(x = support_pred_prey_letter, y = estimate, ymin=lower, ymax=upper))+
  geom_pointrange(aes(color = support_pred_prey2, shape = direction), size = 2, lwd = 2, position= position_dodge(width=.7))+
  scale_color_manual(values = c( "supported_bottom-up" = "springgreen4",
                                 "unsupported_bottom-up" = "gray32",
                                 "supported_top-down" = "darkorange4",
                                 "unsupported_top-down" = "gray32"))+
  scale_shape_manual(values = c("bottom-up" = 15, "top-down" = 18))+
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.6)+
  coord_flip() +  # flip coordinates (puts labels on y axis)
  labs(y = "Weighted effect size", x = NULL, color= NULL, shape = NULL)+ 
  theme_bw()+
  facet_wrap(~var_fancy) +
  theme(axis.text.x = element_text(size = 22), # change these to 28 if going with model size 
        axis.text.y = element_text(size = 22),
        axis.title.x = element_text(size = 22),
        axis.text = element_text(color = "black"),
        legend.title = element_text(size = 22, family = "Helvetica"),
        legend.text = element_text(size = 22, family = "Helvetica"),
        text = element_text(family = "Helvetica"),
        legend.position = "none")
### ehhhh, dont really like this one... 
## but looks much better facetted per variable! 

## see what it looks like only including three observed spatial vars
es_subset = es_final[es_final$var %in% c("Elevation","FLII","HFP"), ]
unique(es_subset$var_letter) # good! 

## check the plot
ggplot(es_subset, aes(x = var_letter, y = estimate, ymin=lower, ymax=upper))+
  geom_pointrange(aes(color = support_pred_prey, shape = direction), size = 2, lwd = 2, position= position_dodge(width=.7))+
    scale_color_manual(values = c( "supported & bottom-up" = "springgreen4",
                                 "unsupported & bottom-up" = "gray32",
                                 "supported & top-down" = "darkorange4",
                                 "unsupported & top-down" = "gray32"))+
  scale_shape_manual(values = c("bottom-up" = 15, "top-down" = 18))+
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.6)+
  coord_flip() +  # flip coordinates (puts labels on y axis)
  labs(y = "Weighted effect size", x = NULL)+ 
  theme_bw()+
  # facet_wrap(~support_pred_prey2) +
  theme(axis.text.x = element_text(size = 22), # change these to 28 if going with model size 
        axis.text.y = element_text(size = 22),
        axis.title.x = element_text(size = 22),
        axis.text = element_text(color = "black"),
        legend.title = element_text(size = 22, family = "Helvetica"),
        legend.text = element_text(size = 22, family = "Helvetica"),
        text = element_text(family = "Helvetica"))
## again, dont love it, not as informative. 


```

I have also re-organized the exact same data from the previous forest plot, but used the facet_wrap to make one plot per variable included. The empty space in the bottom right section would be a good place to add the custom label. The color pattern follows the same pattern as the previous plot. The letter **A)** refers to `r unique(es_final$support_pred_prey[es_final$support_pred_prey_letter == "A)"])`, **B)** refers to `r unique(es_final$support_pred_prey[es_final$support_pred_prey_letter == "B)"])`, **C)** refers to `r unique(es_final$support_pred_prey[es_final$support_pred_prey_letter == "C)"])`, and **D)** refers to `r unique(es_final$support_pred_prey[es_final$support_pred_prey_letter == "D)"])`. 

```{r Visualize the facet_wrap forest plot, include=TRUE, echo=FALSE, fig.width= 12, fig.height=10}
facet_var
```

```{r Try a new regression}
## examine what happens if we overwrite support vs unsupport and just go pred/prey?
# but when we do this, we must remove poor fitting models
## Also, this is similar to what we submitted in our first submission to Science (in supplement) 

### first grab the relevant subset of data 
dat = coeff[coeff$preference == "preferred"  &    ## only preferred models 
              grepl("SUB", coeff$species) &       ## only interested in effect in subordinate species 
              coeff$support != "Unsupported_3" &  ## only interested in models that converged
              coeff$var %in% c(vars, "Species_Interaction"), ]

## Create a new column to denote if the subordinate species is a predator or prey 
dat$pred_prey = "prey" # assume prey 
dat$pred_prey[dat$sub_sp %in% c("Panthera_pardus","Panthera_tigris",
                                "Cuon_alpinus", "Neofelis_genus")] = "predator"

### Will run regressions where the effect size is the response variable
## and the different covariates are the factorial predictors. 
# looped through each subset of data based on pred_prey

## loop through so we dont have to code them all out 
pred_prey = unique(dat$pred_prey)
# store results here
res = list()
# loopin' 
for(i in 1:length(pred_prey)){
 
  # select a pred or prey
  p = pred_prey[i]
    
    ## make the mod w/ the RE 
  m = lmerTest::lmer(mean ~ var-1 + (1 | sub_sp), weights = 1/sd, #REML = FALSE, 
                     data = dat[dat$pred_prey == p, ])
  
  ## extract values
  m1 = as.data.frame(summary(m)$coefficients)
  
  ## clean up the df
  m1$var = rownames(m1)
  m1$var = gsub("var", "", m1$var)
  names(m1) = c("estimate", "SE", "df", "t value", "p value", "var")
  rownames(m1) = NULL
  
  ## let us know if the model converged or not.
  if(is.null(m@optinfo$conv$lme4$messages)){
    m1$warning = "none"
  }else{
    m1$warning = m@optinfo$conv$lme4$messages
  }

  ## explicitly note which model this was
  m1$pred_prey = p

  ## and save it 
  res[[i]] = m1
  
} # end per pred prey 
rm(i,p,m,m1,weights, pred_prey)

## check results 
es_new = do.call(rbind, res)
str(es_new)
tail(es_new)
summary(es_new)
unique(es_new$support_pred_prey[es_new$warning != "none"]) # When we remove REML in lmerTest, there are no more warnings! 

# inspect
summary(es_new$estimate) # narrow range is good! 
summary(es_new$SE) # even smaller, great. 

## update var to say SIV!
vars[grepl("Species", vars)] = "SIV"
# and make sure we match in ES! 
es_new$var[grepl("Species", es_new$var)] = "SIV"

# rename p value
names(es_new)[grepl("p value", names(es_new))] = "p_value"


```

```{r Try a simplified new forest plot}
## make an upper and lower CI
es_new$upper = es_new$estimate + es_new$SE
es_new$lower = es_new$estimate - es_new$SE

## rename vars so they are just letters ordered for the graph
es_new$var_letter[es_new$var == "HFP"] = "A)"
es_new$var_letter[es_new$var == "FLII"] = "B)"
es_new$var_letter[es_new$var == "Elevation"] = "C)"
es_new$var_letter[es_new$var == "Community_detections"] = "D)"
es_new$var_letter[es_new$var == "SIV"] = "E)"

## set the factor order, putting SIV at the bottom
es_new$var_letter = factor(es_new$var_letter, levels = c("E)","D)","C)","B)","A)"))

## set the factor order of points on the graph 
es_new$pred_prey = factor(es_new$pred_prey, levels = c("prey", "predator"))

## check the plot
simple_forest = 
ggplot(es_new, aes(x = var_letter, y = estimate, ymin=lower, ymax=upper))+
  geom_pointrange(aes(color = pred_prey), size = 2, lwd = 2, position= position_dodge(width=.7))+
    scale_color_manual(values = c( "prey" = "springgreen4",
                                 "predator" = "darkorange4"))+
  # scale_shape_manual(values = c("bottom-up" = 15, "top-down" = 18))+
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.6)+
  coord_flip() +  # flip coordinates (puts labels on y axis)
  labs(y = "Weighted effect size", x = NULL)+ 
  theme_bw()+
  # facet_wrap(~support_pred_prey2) +
  theme(axis.text.x = element_text(size = 22), # change these to 28 if going with model size 
        axis.text.y = element_text(size = 22),
        axis.title.x = element_text(size = 22),
        axis.text = element_text(color = "black"),
        legend.title = element_text(size = 22, family = "Helvetica"),
        legend.text = element_text(size = 22, family = "Helvetica"),
        text = element_text(family = "Helvetica"))

```

Below is a simplified version of the forest plot, where supported and unsupported models have been combined to examine predator and prey groupings independently. To ensure the results are not skewed by poor models, **`r length(unique(coeff$Species_Pair[coeff$support == "Unsupported_3"]))` models with a poor goodness of fit or SIV parameters that did not converge (i.e., unsupported_3) have been removed** from this analysis. 

Here are the numerical **results for predators**:

* The variable **`r unique(es_new$var)[1]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "predator"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "predator"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "predator"], 3)`

* The variable **`r unique(es_new$var)[2]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "predator"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "predator"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "predator"], 3)`

* The variable **`r unique(es_new$var)[3]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "predator"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "predator"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "predator"], 3)`

* The variable **`r unique(es_new$var)[4]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "predator"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "predator"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "predator"], 3)`

* The variable **`r unique(es_new$var)[5]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "predator"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "predator"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "predator"], 3)`

Here are the numerical **results for prey**:

* The variable **`r unique(es_new$var)[1]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "prey"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "prey"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[1] & es_new$pred_prey == "prey"], 3)`

* The variable **`r unique(es_new$var)[2]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "prey"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "prey"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[2] & es_new$pred_prey == "prey"], 3)`

* The variable **`r unique(es_new$var)[3]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "prey"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "prey"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[3] & es_new$pred_prey == "prey"], 3)`

* The variable **`r unique(es_new$var)[4]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "prey"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "prey"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[4] & es_new$pred_prey == "prey"], 3)`

* The variable **`r unique(es_new$var)[5]`** had an effect size of `r round(es_new$estimate[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "prey"], 3)` and a standard error of `r round(es_new$SE[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "prey"], 3)` and a p-value of `r round(es_new$p_value[es_new$var == unique(es_new$var)[5] & es_new$pred_prey == "prey"], 3)`


```{r Visualize the simple forest plot, include=TRUE, echo=FALSE, fig.width= 12, fig.height=10}
simple_forest
```

## Save everything! 
Its going here in dropbox: Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/figures/step5_output_forest_plot/

```{r Save the plots!}
# specify the working directory
wd = "/Users/zachary_amir/Dropbox/Zach PhD/Ch3 Trophic release project/SEA_TC_GitHub_data_storage/figures/step5_output_forest_plot/"
# Grab the date
day<-str_sub(Sys.Date(),-2)
month<-str_sub(Sys.Date(),-5,-4)
year<-str_sub(Sys.Date(),-10,-7)
date = paste(year,month,day, sep = "")
rm(year,month,day)
# make a path 
path = paste(wd, "meta-regression_forest_plot_OG_", date, ".png", sep = "")
# save! 
ggsave(path, forest_plot, width = 13, height = 9, units = "in")

## and dont forget the label! 
path = paste(wd, "STEAL_THIS_LABEL_", date, ".png", sep = "")
#save!
ggsave(path, label, width = 13, height = 9, units = "in")

# And now the new facet_wrap plot
path = paste(wd, "meta-regression_forest_plot_facet_wrap_", date, ".png", sep = "")
# save! 
ggsave(path, facet_var, width = 15, height = 9, units = "in")

## and even the silly simple plot
path = paste(wd, "meta-regression_forest_plot_simple_", date, ".png", sep = "")
# save! 
ggsave(path, simple_forest, width = 13, height = 9, units = "in")


```

